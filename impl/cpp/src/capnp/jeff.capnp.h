// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: jeff.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1001000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(ff11858a5d46ba79);
enum class FloatPrecision_ff11858a5d46ba79: uint16_t {
  FLOAT32,
  FLOAT64,
};
CAPNP_DECLARE_ENUM(FloatPrecision, ff11858a5d46ba79);
CAPNP_DECLARE_SCHEMA(8ecf0123694bb7e6);
enum class Pauli_8ecf0123694bb7e6: uint16_t {
  I,
  X,
  Y,
  Z,
};
CAPNP_DECLARE_ENUM(Pauli, 8ecf0123694bb7e6);
CAPNP_DECLARE_SCHEMA(dfc14338fb37a4c0);
enum class WellKnownGate_dfc14338fb37a4c0: uint16_t {
  X,
  Y,
  Z,
  S,
  T,
  R1,
  RX,
  RY,
  RZ,
  H,
  U,
  SWAP,
  I,
  GPHASE,
};
CAPNP_DECLARE_ENUM(WellKnownGate, dfc14338fb37a4c0);
CAPNP_DECLARE_SCHEMA(feaffd89ffd0617b);
CAPNP_DECLARE_SCHEMA(a90356b867db42a5);
CAPNP_DECLARE_SCHEMA(a5e5a1cef5cf0dea);
CAPNP_DECLARE_SCHEMA(c06a025de1b280dc);
CAPNP_DECLARE_SCHEMA(8b4cbb2b39c84d20);
CAPNP_DECLARE_SCHEMA(a94718ae94e9656a);
CAPNP_DECLARE_SCHEMA(fa48502f34c25717);
CAPNP_DECLARE_SCHEMA(c0abcfe5577d0247);
CAPNP_DECLARE_SCHEMA(c905be8527863bef);
CAPNP_DECLARE_SCHEMA(a279c44ec6501fde);
CAPNP_DECLARE_SCHEMA(806a117358065420);
CAPNP_DECLARE_SCHEMA(acfb91813c79f080);
CAPNP_DECLARE_SCHEMA(da042e4455882537);
CAPNP_DECLARE_SCHEMA(a42c8fe16749c25f);
CAPNP_DECLARE_SCHEMA(d935862a88ea5d23);
CAPNP_DECLARE_SCHEMA(e2b436fd2ade024f);
CAPNP_DECLARE_SCHEMA(d2bfc75a0959aa80);
CAPNP_DECLARE_SCHEMA(fc8e0553f20c4eeb);
CAPNP_DECLARE_SCHEMA(9b4cc3fe98f8a54a);
CAPNP_DECLARE_SCHEMA(913d28bca6afcb86);
CAPNP_DECLARE_SCHEMA(f14bb0418f1e8273);
CAPNP_DECLARE_SCHEMA(e2b1243940691d9e);
CAPNP_DECLARE_SCHEMA(c29091e9aba6a350);
CAPNP_DECLARE_SCHEMA(bfefb4a58d54b4fe);

}  // namespace schemas
}  // namespace capnp

namespace jeff {

typedef ::capnp::schemas::FloatPrecision_ff11858a5d46ba79 FloatPrecision;

typedef ::capnp::schemas::Pauli_8ecf0123694bb7e6 Pauli;

typedef ::capnp::schemas::WellKnownGate_dfc14338fb37a4c0 WellKnownGate;

struct Module {
  Module() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(feaffd89ffd0617b, 1, 5)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Function {
  Function() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    DEFINITION,
    DECLARATION,
  };
  struct Definition;
  struct Declaration;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a90356b867db42a5, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Function::Definition {
  Definition() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a5e5a1cef5cf0dea, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Function::Declaration {
  Declaration() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c06a025de1b280dc, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Region {
  Region() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8b4cbb2b39c84d20, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Op {
  Op() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Instruction;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a94718ae94e9656a, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Op::Instruction {
  Instruction() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    QUBIT,
    QUREG,
    INT,
    INT_ARRAY,
    FLOAT,
    FLOAT_ARRAY,
    SCF,
    FUNC,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fa48502f34c25717, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Value {
  Value() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c0abcfe5577d0247, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Type {
  Type() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    QUBIT,
    QUREG,
    INT,
    INT_ARRAY,
    FLOAT,
    FLOAT_ARRAY,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c905be8527863bef, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Meta {
  Meta() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a279c44ec6501fde, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct QubitOp {
  QubitOp() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    ALLOC,
    FREE,
    FREE_ZERO,
    MEASURE,
    MEASURE_ND,
    RESET,
    GATE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(806a117358065420, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct QubitGate {
  QubitGate() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    WELL_KNOWN,
    CUSTOM,
    PPR,
  };
  struct Custom;
  struct Ppr;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(acfb91813c79f080, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct QubitGate::Custom {
  Custom() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(da042e4455882537, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct QubitGate::Ppr {
  Ppr() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a42c8fe16749c25f, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct QuregOp {
  QuregOp() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    ALLOC,
    FREE_ZERO,
    EXTRACT_INDEX,
    INSERT_INDEX,
    EXTRACT_SLICE,
    INSERT_SLICE,
    LENGTH,
    SPLIT,
    JOIN,
    CREATE,
    FREE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d935862a88ea5d23, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct IntOp {
  IntOp() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    CONST1,
    CONST8,
    CONST16,
    CONST32,
    CONST64,
    ADD,
    SUB,
    MUL,
    DIV_S,
    DIV_U,
    POW,
    AND,
    OR,
    XOR,
    NOT,
    MIN_S,
    MIN_U,
    MAX_S,
    MAX_U,
    EQ,
    LT_S,
    LTE_S,
    LT_U,
    LTE_U,
    ABS,
    REM_S,
    REM_U,
    SHL,
    SHR,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e2b436fd2ade024f, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct IntArrayOp {
  IntArrayOp() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    CONST1,
    CONST8,
    CONST16,
    CONST32,
    CONST64,
    ZERO,
    GET_INDEX,
    SET_INDEX,
    LENGTH,
    CREATE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d2bfc75a0959aa80, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FloatOp {
  FloatOp() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    CONST32,
    CONST64,
    ADD,
    SUB,
    MUL,
    POW,
    EQ,
    LT,
    LTE,
    SQRT,
    ABS,
    CEIL,
    FLOOR,
    IS_NAN,
    IS_INF,
    EXP,
    LOG,
    SIN,
    COS,
    TAN,
    ASIN,
    ACOS,
    ATAN,
    ATAN2,
    SINH,
    COSH,
    TANH,
    ASINH,
    ACOSH,
    ATANH,
    MAX,
    MIN,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fc8e0553f20c4eeb, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FloatArrayOp {
  FloatArrayOp() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    CONST32,
    CONST64,
    ZERO,
    GET_INDEX,
    SET_INDEX,
    LENGTH,
    CREATE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9b4cc3fe98f8a54a, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ScfOp {
  ScfOp() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    SWITCH,
    FOR,
    WHILE,
    DO_WHILE,
  };
  struct Switch;
  struct While;
  struct DoWhile;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(913d28bca6afcb86, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ScfOp::Switch {
  Switch() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f14bb0418f1e8273, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ScfOp::While {
  While() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e2b1243940691d9e, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ScfOp::DoWhile {
  DoWhile() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c29091e9aba6a350, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct FuncOp {
  FuncOp() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bfefb4a58d54b4fe, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Module::Reader {
public:
  typedef Module Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVersion() const;

  inline bool hasFunctions() const;
  inline  ::capnp::List< ::jeff::Function,  ::capnp::Kind::STRUCT>::Reader getFunctions() const;

  inline bool hasStrings() const;
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader getStrings() const;

  inline bool hasMetadata() const;
  inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Reader getMetadata() const;

  inline  ::uint16_t getEntrypoint() const;

  inline bool hasTool() const;
  inline  ::capnp::Text::Reader getTool() const;

  inline bool hasToolVersion() const;
  inline  ::capnp::Text::Reader getToolVersion() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Module::Builder {
public:
  typedef Module Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getVersion();
  inline void setVersion( ::uint32_t value);

  inline bool hasFunctions();
  inline  ::capnp::List< ::jeff::Function,  ::capnp::Kind::STRUCT>::Builder getFunctions();
  inline void setFunctions( ::capnp::List< ::jeff::Function,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::jeff::Function,  ::capnp::Kind::STRUCT>::Builder initFunctions(unsigned int size);
  inline void adoptFunctions(::capnp::Orphan< ::capnp::List< ::jeff::Function,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::jeff::Function,  ::capnp::Kind::STRUCT>> disownFunctions();

  inline bool hasStrings();
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder getStrings();
  inline void setStrings( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value);
  inline void setStrings(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder initStrings(unsigned int size);
  inline void adoptStrings(::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> disownStrings();

  inline bool hasMetadata();
  inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Builder getMetadata();
  inline void setMetadata( ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Builder initMetadata(unsigned int size);
  inline void adoptMetadata(::capnp::Orphan< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>> disownMetadata();

  inline  ::uint16_t getEntrypoint();
  inline void setEntrypoint( ::uint16_t value);

  inline bool hasTool();
  inline  ::capnp::Text::Builder getTool();
  inline void setTool( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initTool(unsigned int size);
  inline void adoptTool(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownTool();

  inline bool hasToolVersion();
  inline  ::capnp::Text::Builder getToolVersion();
  inline void setToolVersion( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initToolVersion(unsigned int size);
  inline void adoptToolVersion(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownToolVersion();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Module::Pipeline {
public:
  typedef Module Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Function::Reader {
public:
  typedef Function Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline  ::uint16_t getName() const;

  inline bool isDefinition() const;
  inline typename Definition::Reader getDefinition() const;

  inline bool hasMetadata() const;
  inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Reader getMetadata() const;

  inline bool isDeclaration() const;
  inline typename Declaration::Reader getDeclaration() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Function::Builder {
public:
  typedef Function Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline  ::uint16_t getName();
  inline void setName( ::uint16_t value);

  inline bool isDefinition();
  inline typename Definition::Builder getDefinition();
  inline typename Definition::Builder initDefinition();

  inline bool hasMetadata();
  inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Builder getMetadata();
  inline void setMetadata( ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Builder initMetadata(unsigned int size);
  inline void adoptMetadata(::capnp::Orphan< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>> disownMetadata();

  inline bool isDeclaration();
  inline typename Declaration::Builder getDeclaration();
  inline typename Declaration::Builder initDeclaration();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Function::Pipeline {
public:
  typedef Function Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Function::Definition::Reader {
public:
  typedef Definition Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBody() const;
  inline  ::jeff::Region::Reader getBody() const;

  inline bool hasValues() const;
  inline  ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Reader getValues() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Function::Definition::Builder {
public:
  typedef Definition Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBody();
  inline  ::jeff::Region::Builder getBody();
  inline void setBody( ::jeff::Region::Reader value);
  inline  ::jeff::Region::Builder initBody();
  inline void adoptBody(::capnp::Orphan< ::jeff::Region>&& value);
  inline ::capnp::Orphan< ::jeff::Region> disownBody();

  inline bool hasValues();
  inline  ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Builder getValues();
  inline void setValues( ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Builder initValues(unsigned int size);
  inline void adoptValues(::capnp::Orphan< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>> disownValues();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Function::Definition::Pipeline {
public:
  typedef Definition Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::jeff::Region::Pipeline getBody();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Function::Declaration::Reader {
public:
  typedef Declaration Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasInputs() const;
  inline  ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Reader getInputs() const;

  inline bool hasOutputs() const;
  inline  ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Reader getOutputs() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Function::Declaration::Builder {
public:
  typedef Declaration Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInputs();
  inline  ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Builder getInputs();
  inline void setInputs( ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Builder initInputs(unsigned int size);
  inline void adoptInputs(::capnp::Orphan< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>> disownInputs();

  inline bool hasOutputs();
  inline  ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Builder getOutputs();
  inline void setOutputs( ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Builder initOutputs(unsigned int size);
  inline void adoptOutputs(::capnp::Orphan< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>> disownOutputs();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Function::Declaration::Pipeline {
public:
  typedef Declaration Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Region::Reader {
public:
  typedef Region Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasSources() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getSources() const;

  inline bool hasTargets() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getTargets() const;

  inline bool hasOperations() const;
  inline  ::capnp::List< ::jeff::Op,  ::capnp::Kind::STRUCT>::Reader getOperations() const;

  inline bool hasMetadata() const;
  inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Reader getMetadata() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Region::Builder {
public:
  typedef Region Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasSources();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getSources();
  inline void setSources( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setSources(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initSources(unsigned int size);
  inline void adoptSources(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownSources();

  inline bool hasTargets();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getTargets();
  inline void setTargets( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setTargets(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initTargets(unsigned int size);
  inline void adoptTargets(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownTargets();

  inline bool hasOperations();
  inline  ::capnp::List< ::jeff::Op,  ::capnp::Kind::STRUCT>::Builder getOperations();
  inline void setOperations( ::capnp::List< ::jeff::Op,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::jeff::Op,  ::capnp::Kind::STRUCT>::Builder initOperations(unsigned int size);
  inline void adoptOperations(::capnp::Orphan< ::capnp::List< ::jeff::Op,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::jeff::Op,  ::capnp::Kind::STRUCT>> disownOperations();

  inline bool hasMetadata();
  inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Builder getMetadata();
  inline void setMetadata( ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Builder initMetadata(unsigned int size);
  inline void adoptMetadata(::capnp::Orphan< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>> disownMetadata();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Region::Pipeline {
public:
  typedef Region Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Op::Reader {
public:
  typedef Op Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasInputs() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getInputs() const;

  inline bool hasOutputs() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getOutputs() const;

  inline bool hasMetadata() const;
  inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Reader getMetadata() const;

  inline typename Instruction::Reader getInstruction() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Op::Builder {
public:
  typedef Op Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInputs();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getInputs();
  inline void setInputs( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setInputs(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initInputs(unsigned int size);
  inline void adoptInputs(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownInputs();

  inline bool hasOutputs();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getOutputs();
  inline void setOutputs( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setOutputs(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initOutputs(unsigned int size);
  inline void adoptOutputs(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownOutputs();

  inline bool hasMetadata();
  inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Builder getMetadata();
  inline void setMetadata( ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Builder initMetadata(unsigned int size);
  inline void adoptMetadata(::capnp::Orphan< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>> disownMetadata();

  inline typename Instruction::Builder getInstruction();
  inline typename Instruction::Builder initInstruction();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Op::Pipeline {
public:
  typedef Op Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename Instruction::Pipeline getInstruction();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Op::Instruction::Reader {
public:
  typedef Instruction Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isQubit() const;
  inline bool hasQubit() const;
  inline  ::jeff::QubitOp::Reader getQubit() const;

  inline bool isQureg() const;
  inline bool hasQureg() const;
  inline  ::jeff::QuregOp::Reader getQureg() const;

  inline bool isInt() const;
  inline bool hasInt() const;
  inline  ::jeff::IntOp::Reader getInt() const;

  inline bool isIntArray() const;
  inline bool hasIntArray() const;
  inline  ::jeff::IntArrayOp::Reader getIntArray() const;

  inline bool isFloat() const;
  inline bool hasFloat() const;
  inline  ::jeff::FloatOp::Reader getFloat() const;

  inline bool isFloatArray() const;
  inline bool hasFloatArray() const;
  inline  ::jeff::FloatArrayOp::Reader getFloatArray() const;

  inline bool isScf() const;
  inline bool hasScf() const;
  inline  ::jeff::ScfOp::Reader getScf() const;

  inline bool isFunc() const;
  inline bool hasFunc() const;
  inline  ::jeff::FuncOp::Reader getFunc() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Op::Instruction::Builder {
public:
  typedef Instruction Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isQubit();
  inline bool hasQubit();
  inline  ::jeff::QubitOp::Builder getQubit();
  inline void setQubit( ::jeff::QubitOp::Reader value);
  inline  ::jeff::QubitOp::Builder initQubit();
  inline void adoptQubit(::capnp::Orphan< ::jeff::QubitOp>&& value);
  inline ::capnp::Orphan< ::jeff::QubitOp> disownQubit();

  inline bool isQureg();
  inline bool hasQureg();
  inline  ::jeff::QuregOp::Builder getQureg();
  inline void setQureg( ::jeff::QuregOp::Reader value);
  inline  ::jeff::QuregOp::Builder initQureg();
  inline void adoptQureg(::capnp::Orphan< ::jeff::QuregOp>&& value);
  inline ::capnp::Orphan< ::jeff::QuregOp> disownQureg();

  inline bool isInt();
  inline bool hasInt();
  inline  ::jeff::IntOp::Builder getInt();
  inline void setInt( ::jeff::IntOp::Reader value);
  inline  ::jeff::IntOp::Builder initInt();
  inline void adoptInt(::capnp::Orphan< ::jeff::IntOp>&& value);
  inline ::capnp::Orphan< ::jeff::IntOp> disownInt();

  inline bool isIntArray();
  inline bool hasIntArray();
  inline  ::jeff::IntArrayOp::Builder getIntArray();
  inline void setIntArray( ::jeff::IntArrayOp::Reader value);
  inline  ::jeff::IntArrayOp::Builder initIntArray();
  inline void adoptIntArray(::capnp::Orphan< ::jeff::IntArrayOp>&& value);
  inline ::capnp::Orphan< ::jeff::IntArrayOp> disownIntArray();

  inline bool isFloat();
  inline bool hasFloat();
  inline  ::jeff::FloatOp::Builder getFloat();
  inline void setFloat( ::jeff::FloatOp::Reader value);
  inline  ::jeff::FloatOp::Builder initFloat();
  inline void adoptFloat(::capnp::Orphan< ::jeff::FloatOp>&& value);
  inline ::capnp::Orphan< ::jeff::FloatOp> disownFloat();

  inline bool isFloatArray();
  inline bool hasFloatArray();
  inline  ::jeff::FloatArrayOp::Builder getFloatArray();
  inline void setFloatArray( ::jeff::FloatArrayOp::Reader value);
  inline  ::jeff::FloatArrayOp::Builder initFloatArray();
  inline void adoptFloatArray(::capnp::Orphan< ::jeff::FloatArrayOp>&& value);
  inline ::capnp::Orphan< ::jeff::FloatArrayOp> disownFloatArray();

  inline bool isScf();
  inline bool hasScf();
  inline  ::jeff::ScfOp::Builder getScf();
  inline void setScf( ::jeff::ScfOp::Reader value);
  inline  ::jeff::ScfOp::Builder initScf();
  inline void adoptScf(::capnp::Orphan< ::jeff::ScfOp>&& value);
  inline ::capnp::Orphan< ::jeff::ScfOp> disownScf();

  inline bool isFunc();
  inline bool hasFunc();
  inline  ::jeff::FuncOp::Builder getFunc();
  inline void setFunc( ::jeff::FuncOp::Reader value);
  inline  ::jeff::FuncOp::Builder initFunc();
  inline void adoptFunc(::capnp::Orphan< ::jeff::FuncOp>&& value);
  inline ::capnp::Orphan< ::jeff::FuncOp> disownFunc();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Op::Instruction::Pipeline {
public:
  typedef Instruction Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Value::Reader {
public:
  typedef Value Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasType() const;
  inline  ::jeff::Type::Reader getType() const;

  inline bool hasMetadata() const;
  inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Reader getMetadata() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Value::Builder {
public:
  typedef Value Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasType();
  inline  ::jeff::Type::Builder getType();
  inline void setType( ::jeff::Type::Reader value);
  inline  ::jeff::Type::Builder initType();
  inline void adoptType(::capnp::Orphan< ::jeff::Type>&& value);
  inline ::capnp::Orphan< ::jeff::Type> disownType();

  inline bool hasMetadata();
  inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Builder getMetadata();
  inline void setMetadata( ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Builder initMetadata(unsigned int size);
  inline void adoptMetadata(::capnp::Orphan< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>> disownMetadata();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Value::Pipeline {
public:
  typedef Value Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::jeff::Type::Pipeline getType();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Type::Reader {
public:
  typedef Type Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isQubit() const;
  inline  ::capnp::Void getQubit() const;

  inline bool isQureg() const;
  inline  ::capnp::Void getQureg() const;

  inline bool isInt() const;
  inline  ::uint8_t getInt() const;

  inline bool isIntArray() const;
  inline  ::uint8_t getIntArray() const;

  inline bool isFloat() const;
  inline  ::jeff::FloatPrecision getFloat() const;

  inline bool isFloatArray() const;
  inline  ::jeff::FloatPrecision getFloatArray() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Type::Builder {
public:
  typedef Type Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isQubit();
  inline  ::capnp::Void getQubit();
  inline void setQubit( ::capnp::Void value = ::capnp::VOID);

  inline bool isQureg();
  inline  ::capnp::Void getQureg();
  inline void setQureg( ::capnp::Void value = ::capnp::VOID);

  inline bool isInt();
  inline  ::uint8_t getInt();
  inline void setInt( ::uint8_t value);

  inline bool isIntArray();
  inline  ::uint8_t getIntArray();
  inline void setIntArray( ::uint8_t value);

  inline bool isFloat();
  inline  ::jeff::FloatPrecision getFloat();
  inline void setFloat( ::jeff::FloatPrecision value);

  inline bool isFloatArray();
  inline  ::jeff::FloatPrecision getFloatArray();
  inline void setFloatArray( ::jeff::FloatPrecision value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Type::Pipeline {
public:
  typedef Type Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Meta::Reader {
public:
  typedef Meta Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getName() const;

  inline bool hasValue() const;
  inline ::capnp::AnyPointer::Reader getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Meta::Builder {
public:
  typedef Meta Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getName();
  inline void setName( ::uint16_t value);

  inline bool hasValue();
  inline ::capnp::AnyPointer::Builder getValue();
  inline ::capnp::AnyPointer::Builder initValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Meta::Pipeline {
public:
  typedef Meta Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class QubitOp::Reader {
public:
  typedef QubitOp Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isAlloc() const;
  inline  ::capnp::Void getAlloc() const;

  inline bool isFree() const;
  inline  ::capnp::Void getFree() const;

  inline bool isFreeZero() const;
  inline  ::capnp::Void getFreeZero() const;

  inline bool isMeasure() const;
  inline  ::capnp::Void getMeasure() const;

  inline bool isMeasureNd() const;
  inline  ::capnp::Void getMeasureNd() const;

  inline bool isReset() const;
  inline  ::capnp::Void getReset() const;

  inline bool isGate() const;
  inline bool hasGate() const;
  inline  ::jeff::QubitGate::Reader getGate() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class QubitOp::Builder {
public:
  typedef QubitOp Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isAlloc();
  inline  ::capnp::Void getAlloc();
  inline void setAlloc( ::capnp::Void value = ::capnp::VOID);

  inline bool isFree();
  inline  ::capnp::Void getFree();
  inline void setFree( ::capnp::Void value = ::capnp::VOID);

  inline bool isFreeZero();
  inline  ::capnp::Void getFreeZero();
  inline void setFreeZero( ::capnp::Void value = ::capnp::VOID);

  inline bool isMeasure();
  inline  ::capnp::Void getMeasure();
  inline void setMeasure( ::capnp::Void value = ::capnp::VOID);

  inline bool isMeasureNd();
  inline  ::capnp::Void getMeasureNd();
  inline void setMeasureNd( ::capnp::Void value = ::capnp::VOID);

  inline bool isReset();
  inline  ::capnp::Void getReset();
  inline void setReset( ::capnp::Void value = ::capnp::VOID);

  inline bool isGate();
  inline bool hasGate();
  inline  ::jeff::QubitGate::Builder getGate();
  inline void setGate( ::jeff::QubitGate::Reader value);
  inline  ::jeff::QubitGate::Builder initGate();
  inline void adoptGate(::capnp::Orphan< ::jeff::QubitGate>&& value);
  inline ::capnp::Orphan< ::jeff::QubitGate> disownGate();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class QubitOp::Pipeline {
public:
  typedef QubitOp Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class QubitGate::Reader {
public:
  typedef QubitGate Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isWellKnown() const;
  inline  ::jeff::WellKnownGate getWellKnown() const;

  inline bool isCustom() const;
  inline typename Custom::Reader getCustom() const;

  inline  ::uint8_t getControlQubits() const;

  inline bool getAdjoint() const;

  inline  ::uint8_t getPower() const;

  inline bool isPpr() const;
  inline typename Ppr::Reader getPpr() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class QubitGate::Builder {
public:
  typedef QubitGate Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isWellKnown();
  inline  ::jeff::WellKnownGate getWellKnown();
  inline void setWellKnown( ::jeff::WellKnownGate value);

  inline bool isCustom();
  inline typename Custom::Builder getCustom();
  inline typename Custom::Builder initCustom();

  inline  ::uint8_t getControlQubits();
  inline void setControlQubits( ::uint8_t value);

  inline bool getAdjoint();
  inline void setAdjoint(bool value);

  inline  ::uint8_t getPower();
  inline void setPower( ::uint8_t value);

  inline bool isPpr();
  inline typename Ppr::Builder getPpr();
  inline typename Ppr::Builder initPpr();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class QubitGate::Pipeline {
public:
  typedef QubitGate Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class QubitGate::Custom::Reader {
public:
  typedef Custom Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getName() const;

  inline  ::uint8_t getNumQubits() const;

  inline  ::uint8_t getNumParams() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class QubitGate::Custom::Builder {
public:
  typedef Custom Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getName();
  inline void setName( ::uint16_t value);

  inline  ::uint8_t getNumQubits();
  inline void setNumQubits( ::uint8_t value);

  inline  ::uint8_t getNumParams();
  inline void setNumParams( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class QubitGate::Custom::Pipeline {
public:
  typedef Custom Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class QubitGate::Ppr::Reader {
public:
  typedef Ppr Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPauliString() const;
  inline  ::capnp::List< ::jeff::Pauli,  ::capnp::Kind::ENUM>::Reader getPauliString() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class QubitGate::Ppr::Builder {
public:
  typedef Ppr Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPauliString();
  inline  ::capnp::List< ::jeff::Pauli,  ::capnp::Kind::ENUM>::Builder getPauliString();
  inline void setPauliString( ::capnp::List< ::jeff::Pauli,  ::capnp::Kind::ENUM>::Reader value);
  inline void setPauliString(::kj::ArrayPtr<const  ::jeff::Pauli> value);
  inline  ::capnp::List< ::jeff::Pauli,  ::capnp::Kind::ENUM>::Builder initPauliString(unsigned int size);
  inline void adoptPauliString(::capnp::Orphan< ::capnp::List< ::jeff::Pauli,  ::capnp::Kind::ENUM>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::jeff::Pauli,  ::capnp::Kind::ENUM>> disownPauliString();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class QubitGate::Ppr::Pipeline {
public:
  typedef Ppr Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class QuregOp::Reader {
public:
  typedef QuregOp Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isAlloc() const;
  inline  ::capnp::Void getAlloc() const;

  inline bool isFreeZero() const;
  inline  ::capnp::Void getFreeZero() const;

  inline bool isExtractIndex() const;
  inline  ::capnp::Void getExtractIndex() const;

  inline bool isInsertIndex() const;
  inline  ::capnp::Void getInsertIndex() const;

  inline bool isExtractSlice() const;
  inline  ::capnp::Void getExtractSlice() const;

  inline bool isInsertSlice() const;
  inline  ::capnp::Void getInsertSlice() const;

  inline bool isLength() const;
  inline  ::capnp::Void getLength() const;

  inline bool isSplit() const;
  inline  ::capnp::Void getSplit() const;

  inline bool isJoin() const;
  inline  ::capnp::Void getJoin() const;

  inline bool isCreate() const;
  inline  ::capnp::Void getCreate() const;

  inline bool isFree() const;
  inline  ::capnp::Void getFree() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class QuregOp::Builder {
public:
  typedef QuregOp Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isAlloc();
  inline  ::capnp::Void getAlloc();
  inline void setAlloc( ::capnp::Void value = ::capnp::VOID);

  inline bool isFreeZero();
  inline  ::capnp::Void getFreeZero();
  inline void setFreeZero( ::capnp::Void value = ::capnp::VOID);

  inline bool isExtractIndex();
  inline  ::capnp::Void getExtractIndex();
  inline void setExtractIndex( ::capnp::Void value = ::capnp::VOID);

  inline bool isInsertIndex();
  inline  ::capnp::Void getInsertIndex();
  inline void setInsertIndex( ::capnp::Void value = ::capnp::VOID);

  inline bool isExtractSlice();
  inline  ::capnp::Void getExtractSlice();
  inline void setExtractSlice( ::capnp::Void value = ::capnp::VOID);

  inline bool isInsertSlice();
  inline  ::capnp::Void getInsertSlice();
  inline void setInsertSlice( ::capnp::Void value = ::capnp::VOID);

  inline bool isLength();
  inline  ::capnp::Void getLength();
  inline void setLength( ::capnp::Void value = ::capnp::VOID);

  inline bool isSplit();
  inline  ::capnp::Void getSplit();
  inline void setSplit( ::capnp::Void value = ::capnp::VOID);

  inline bool isJoin();
  inline  ::capnp::Void getJoin();
  inline void setJoin( ::capnp::Void value = ::capnp::VOID);

  inline bool isCreate();
  inline  ::capnp::Void getCreate();
  inline void setCreate( ::capnp::Void value = ::capnp::VOID);

  inline bool isFree();
  inline  ::capnp::Void getFree();
  inline void setFree( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class QuregOp::Pipeline {
public:
  typedef QuregOp Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IntOp::Reader {
public:
  typedef IntOp Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isConst1() const;
  inline bool getConst1() const;

  inline bool isConst8() const;
  inline  ::uint8_t getConst8() const;

  inline bool isConst16() const;
  inline  ::uint16_t getConst16() const;

  inline bool isConst32() const;
  inline  ::uint32_t getConst32() const;

  inline bool isConst64() const;
  inline  ::uint64_t getConst64() const;

  inline bool isAdd() const;
  inline  ::capnp::Void getAdd() const;

  inline bool isSub() const;
  inline  ::capnp::Void getSub() const;

  inline bool isMul() const;
  inline  ::capnp::Void getMul() const;

  inline bool isDivS() const;
  inline  ::capnp::Void getDivS() const;

  inline bool isDivU() const;
  inline  ::capnp::Void getDivU() const;

  inline bool isPow() const;
  inline  ::capnp::Void getPow() const;

  inline bool isAnd() const;
  inline  ::capnp::Void getAnd() const;

  inline bool isOr() const;
  inline  ::capnp::Void getOr() const;

  inline bool isXor() const;
  inline  ::capnp::Void getXor() const;

  inline bool isNot() const;
  inline  ::capnp::Void getNot() const;

  inline bool isMinS() const;
  inline  ::capnp::Void getMinS() const;

  inline bool isMinU() const;
  inline  ::capnp::Void getMinU() const;

  inline bool isMaxS() const;
  inline  ::capnp::Void getMaxS() const;

  inline bool isMaxU() const;
  inline  ::capnp::Void getMaxU() const;

  inline bool isEq() const;
  inline  ::capnp::Void getEq() const;

  inline bool isLtS() const;
  inline  ::capnp::Void getLtS() const;

  inline bool isLteS() const;
  inline  ::capnp::Void getLteS() const;

  inline bool isLtU() const;
  inline  ::capnp::Void getLtU() const;

  inline bool isLteU() const;
  inline  ::capnp::Void getLteU() const;

  inline bool isAbs() const;
  inline  ::capnp::Void getAbs() const;

  inline bool isRemS() const;
  inline  ::capnp::Void getRemS() const;

  inline bool isRemU() const;
  inline  ::capnp::Void getRemU() const;

  inline bool isShl() const;
  inline  ::capnp::Void getShl() const;

  inline bool isShr() const;
  inline  ::capnp::Void getShr() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IntOp::Builder {
public:
  typedef IntOp Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isConst1();
  inline bool getConst1();
  inline void setConst1(bool value);

  inline bool isConst8();
  inline  ::uint8_t getConst8();
  inline void setConst8( ::uint8_t value);

  inline bool isConst16();
  inline  ::uint16_t getConst16();
  inline void setConst16( ::uint16_t value);

  inline bool isConst32();
  inline  ::uint32_t getConst32();
  inline void setConst32( ::uint32_t value);

  inline bool isConst64();
  inline  ::uint64_t getConst64();
  inline void setConst64( ::uint64_t value);

  inline bool isAdd();
  inline  ::capnp::Void getAdd();
  inline void setAdd( ::capnp::Void value = ::capnp::VOID);

  inline bool isSub();
  inline  ::capnp::Void getSub();
  inline void setSub( ::capnp::Void value = ::capnp::VOID);

  inline bool isMul();
  inline  ::capnp::Void getMul();
  inline void setMul( ::capnp::Void value = ::capnp::VOID);

  inline bool isDivS();
  inline  ::capnp::Void getDivS();
  inline void setDivS( ::capnp::Void value = ::capnp::VOID);

  inline bool isDivU();
  inline  ::capnp::Void getDivU();
  inline void setDivU( ::capnp::Void value = ::capnp::VOID);

  inline bool isPow();
  inline  ::capnp::Void getPow();
  inline void setPow( ::capnp::Void value = ::capnp::VOID);

  inline bool isAnd();
  inline  ::capnp::Void getAnd();
  inline void setAnd( ::capnp::Void value = ::capnp::VOID);

  inline bool isOr();
  inline  ::capnp::Void getOr();
  inline void setOr( ::capnp::Void value = ::capnp::VOID);

  inline bool isXor();
  inline  ::capnp::Void getXor();
  inline void setXor( ::capnp::Void value = ::capnp::VOID);

  inline bool isNot();
  inline  ::capnp::Void getNot();
  inline void setNot( ::capnp::Void value = ::capnp::VOID);

  inline bool isMinS();
  inline  ::capnp::Void getMinS();
  inline void setMinS( ::capnp::Void value = ::capnp::VOID);

  inline bool isMinU();
  inline  ::capnp::Void getMinU();
  inline void setMinU( ::capnp::Void value = ::capnp::VOID);

  inline bool isMaxS();
  inline  ::capnp::Void getMaxS();
  inline void setMaxS( ::capnp::Void value = ::capnp::VOID);

  inline bool isMaxU();
  inline  ::capnp::Void getMaxU();
  inline void setMaxU( ::capnp::Void value = ::capnp::VOID);

  inline bool isEq();
  inline  ::capnp::Void getEq();
  inline void setEq( ::capnp::Void value = ::capnp::VOID);

  inline bool isLtS();
  inline  ::capnp::Void getLtS();
  inline void setLtS( ::capnp::Void value = ::capnp::VOID);

  inline bool isLteS();
  inline  ::capnp::Void getLteS();
  inline void setLteS( ::capnp::Void value = ::capnp::VOID);

  inline bool isLtU();
  inline  ::capnp::Void getLtU();
  inline void setLtU( ::capnp::Void value = ::capnp::VOID);

  inline bool isLteU();
  inline  ::capnp::Void getLteU();
  inline void setLteU( ::capnp::Void value = ::capnp::VOID);

  inline bool isAbs();
  inline  ::capnp::Void getAbs();
  inline void setAbs( ::capnp::Void value = ::capnp::VOID);

  inline bool isRemS();
  inline  ::capnp::Void getRemS();
  inline void setRemS( ::capnp::Void value = ::capnp::VOID);

  inline bool isRemU();
  inline  ::capnp::Void getRemU();
  inline void setRemU( ::capnp::Void value = ::capnp::VOID);

  inline bool isShl();
  inline  ::capnp::Void getShl();
  inline void setShl( ::capnp::Void value = ::capnp::VOID);

  inline bool isShr();
  inline  ::capnp::Void getShr();
  inline void setShr( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IntOp::Pipeline {
public:
  typedef IntOp Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IntArrayOp::Reader {
public:
  typedef IntArrayOp Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isConst1() const;
  inline bool hasConst1() const;
  inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Reader getConst1() const;

  inline bool isConst8() const;
  inline bool hasConst8() const;
  inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader getConst8() const;

  inline bool isConst16() const;
  inline bool hasConst16() const;
  inline  ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>::Reader getConst16() const;

  inline bool isConst32() const;
  inline bool hasConst32() const;
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader getConst32() const;

  inline bool isConst64() const;
  inline bool hasConst64() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getConst64() const;

  inline bool isZero() const;
  inline  ::uint8_t getZero() const;

  inline bool isGetIndex() const;
  inline  ::capnp::Void getGetIndex() const;

  inline bool isSetIndex() const;
  inline  ::capnp::Void getSetIndex() const;

  inline bool isLength() const;
  inline  ::capnp::Void getLength() const;

  inline bool isCreate() const;
  inline  ::capnp::Void getCreate() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IntArrayOp::Builder {
public:
  typedef IntArrayOp Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isConst1();
  inline bool hasConst1();
  inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Builder getConst1();
  inline void setConst1( ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setConst1(::kj::ArrayPtr<const bool> value);
  inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Builder initConst1(unsigned int size);
  inline void adoptConst1(::capnp::Orphan< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>> disownConst1();

  inline bool isConst8();
  inline bool hasConst8();
  inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder getConst8();
  inline void setConst8( ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setConst8(::kj::ArrayPtr<const  ::uint8_t> value);
  inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder initConst8(unsigned int size);
  inline void adoptConst8(::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>> disownConst8();

  inline bool isConst16();
  inline bool hasConst16();
  inline  ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>::Builder getConst16();
  inline void setConst16( ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setConst16(::kj::ArrayPtr<const  ::uint16_t> value);
  inline  ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>::Builder initConst16(unsigned int size);
  inline void adoptConst16(::capnp::Orphan< ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>> disownConst16();

  inline bool isConst32();
  inline bool hasConst32();
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder getConst32();
  inline void setConst32( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setConst32(::kj::ArrayPtr<const  ::uint32_t> value);
  inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder initConst32(unsigned int size);
  inline void adoptConst32(::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> disownConst32();

  inline bool isConst64();
  inline bool hasConst64();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getConst64();
  inline void setConst64( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setConst64(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initConst64(unsigned int size);
  inline void adoptConst64(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownConst64();

  inline bool isZero();
  inline  ::uint8_t getZero();
  inline void setZero( ::uint8_t value);

  inline bool isGetIndex();
  inline  ::capnp::Void getGetIndex();
  inline void setGetIndex( ::capnp::Void value = ::capnp::VOID);

  inline bool isSetIndex();
  inline  ::capnp::Void getSetIndex();
  inline void setSetIndex( ::capnp::Void value = ::capnp::VOID);

  inline bool isLength();
  inline  ::capnp::Void getLength();
  inline void setLength( ::capnp::Void value = ::capnp::VOID);

  inline bool isCreate();
  inline  ::capnp::Void getCreate();
  inline void setCreate( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IntArrayOp::Pipeline {
public:
  typedef IntArrayOp Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FloatOp::Reader {
public:
  typedef FloatOp Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isConst32() const;
  inline float getConst32() const;

  inline bool isConst64() const;
  inline double getConst64() const;

  inline bool isAdd() const;
  inline  ::capnp::Void getAdd() const;

  inline bool isSub() const;
  inline  ::capnp::Void getSub() const;

  inline bool isMul() const;
  inline  ::capnp::Void getMul() const;

  inline bool isPow() const;
  inline  ::capnp::Void getPow() const;

  inline bool isEq() const;
  inline  ::capnp::Void getEq() const;

  inline bool isLt() const;
  inline  ::capnp::Void getLt() const;

  inline bool isLte() const;
  inline  ::capnp::Void getLte() const;

  inline bool isSqrt() const;
  inline  ::capnp::Void getSqrt() const;

  inline bool isAbs() const;
  inline  ::capnp::Void getAbs() const;

  inline bool isCeil() const;
  inline  ::capnp::Void getCeil() const;

  inline bool isFloor() const;
  inline  ::capnp::Void getFloor() const;

  inline bool isIsNan() const;
  inline  ::capnp::Void getIsNan() const;

  inline bool isIsInf() const;
  inline  ::capnp::Void getIsInf() const;

  inline bool isExp() const;
  inline  ::capnp::Void getExp() const;

  inline bool isLog() const;
  inline  ::capnp::Void getLog() const;

  inline bool isSin() const;
  inline  ::capnp::Void getSin() const;

  inline bool isCos() const;
  inline  ::capnp::Void getCos() const;

  inline bool isTan() const;
  inline  ::capnp::Void getTan() const;

  inline bool isAsin() const;
  inline  ::capnp::Void getAsin() const;

  inline bool isAcos() const;
  inline  ::capnp::Void getAcos() const;

  inline bool isAtan() const;
  inline  ::capnp::Void getAtan() const;

  inline bool isAtan2() const;
  inline  ::capnp::Void getAtan2() const;

  inline bool isSinh() const;
  inline  ::capnp::Void getSinh() const;

  inline bool isCosh() const;
  inline  ::capnp::Void getCosh() const;

  inline bool isTanh() const;
  inline  ::capnp::Void getTanh() const;

  inline bool isAsinh() const;
  inline  ::capnp::Void getAsinh() const;

  inline bool isAcosh() const;
  inline  ::capnp::Void getAcosh() const;

  inline bool isAtanh() const;
  inline  ::capnp::Void getAtanh() const;

  inline bool isMax() const;
  inline  ::capnp::Void getMax() const;

  inline bool isMin() const;
  inline  ::capnp::Void getMin() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FloatOp::Builder {
public:
  typedef FloatOp Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isConst32();
  inline float getConst32();
  inline void setConst32(float value);

  inline bool isConst64();
  inline double getConst64();
  inline void setConst64(double value);

  inline bool isAdd();
  inline  ::capnp::Void getAdd();
  inline void setAdd( ::capnp::Void value = ::capnp::VOID);

  inline bool isSub();
  inline  ::capnp::Void getSub();
  inline void setSub( ::capnp::Void value = ::capnp::VOID);

  inline bool isMul();
  inline  ::capnp::Void getMul();
  inline void setMul( ::capnp::Void value = ::capnp::VOID);

  inline bool isPow();
  inline  ::capnp::Void getPow();
  inline void setPow( ::capnp::Void value = ::capnp::VOID);

  inline bool isEq();
  inline  ::capnp::Void getEq();
  inline void setEq( ::capnp::Void value = ::capnp::VOID);

  inline bool isLt();
  inline  ::capnp::Void getLt();
  inline void setLt( ::capnp::Void value = ::capnp::VOID);

  inline bool isLte();
  inline  ::capnp::Void getLte();
  inline void setLte( ::capnp::Void value = ::capnp::VOID);

  inline bool isSqrt();
  inline  ::capnp::Void getSqrt();
  inline void setSqrt( ::capnp::Void value = ::capnp::VOID);

  inline bool isAbs();
  inline  ::capnp::Void getAbs();
  inline void setAbs( ::capnp::Void value = ::capnp::VOID);

  inline bool isCeil();
  inline  ::capnp::Void getCeil();
  inline void setCeil( ::capnp::Void value = ::capnp::VOID);

  inline bool isFloor();
  inline  ::capnp::Void getFloor();
  inline void setFloor( ::capnp::Void value = ::capnp::VOID);

  inline bool isIsNan();
  inline  ::capnp::Void getIsNan();
  inline void setIsNan( ::capnp::Void value = ::capnp::VOID);

  inline bool isIsInf();
  inline  ::capnp::Void getIsInf();
  inline void setIsInf( ::capnp::Void value = ::capnp::VOID);

  inline bool isExp();
  inline  ::capnp::Void getExp();
  inline void setExp( ::capnp::Void value = ::capnp::VOID);

  inline bool isLog();
  inline  ::capnp::Void getLog();
  inline void setLog( ::capnp::Void value = ::capnp::VOID);

  inline bool isSin();
  inline  ::capnp::Void getSin();
  inline void setSin( ::capnp::Void value = ::capnp::VOID);

  inline bool isCos();
  inline  ::capnp::Void getCos();
  inline void setCos( ::capnp::Void value = ::capnp::VOID);

  inline bool isTan();
  inline  ::capnp::Void getTan();
  inline void setTan( ::capnp::Void value = ::capnp::VOID);

  inline bool isAsin();
  inline  ::capnp::Void getAsin();
  inline void setAsin( ::capnp::Void value = ::capnp::VOID);

  inline bool isAcos();
  inline  ::capnp::Void getAcos();
  inline void setAcos( ::capnp::Void value = ::capnp::VOID);

  inline bool isAtan();
  inline  ::capnp::Void getAtan();
  inline void setAtan( ::capnp::Void value = ::capnp::VOID);

  inline bool isAtan2();
  inline  ::capnp::Void getAtan2();
  inline void setAtan2( ::capnp::Void value = ::capnp::VOID);

  inline bool isSinh();
  inline  ::capnp::Void getSinh();
  inline void setSinh( ::capnp::Void value = ::capnp::VOID);

  inline bool isCosh();
  inline  ::capnp::Void getCosh();
  inline void setCosh( ::capnp::Void value = ::capnp::VOID);

  inline bool isTanh();
  inline  ::capnp::Void getTanh();
  inline void setTanh( ::capnp::Void value = ::capnp::VOID);

  inline bool isAsinh();
  inline  ::capnp::Void getAsinh();
  inline void setAsinh( ::capnp::Void value = ::capnp::VOID);

  inline bool isAcosh();
  inline  ::capnp::Void getAcosh();
  inline void setAcosh( ::capnp::Void value = ::capnp::VOID);

  inline bool isAtanh();
  inline  ::capnp::Void getAtanh();
  inline void setAtanh( ::capnp::Void value = ::capnp::VOID);

  inline bool isMax();
  inline  ::capnp::Void getMax();
  inline void setMax( ::capnp::Void value = ::capnp::VOID);

  inline bool isMin();
  inline  ::capnp::Void getMin();
  inline void setMin( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FloatOp::Pipeline {
public:
  typedef FloatOp Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FloatArrayOp::Reader {
public:
  typedef FloatArrayOp Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isConst32() const;
  inline bool hasConst32() const;
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader getConst32() const;

  inline bool isConst64() const;
  inline bool hasConst64() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getConst64() const;

  inline bool isZero() const;
  inline  ::jeff::FloatPrecision getZero() const;

  inline bool isGetIndex() const;
  inline  ::capnp::Void getGetIndex() const;

  inline bool isSetIndex() const;
  inline  ::capnp::Void getSetIndex() const;

  inline bool isLength() const;
  inline  ::capnp::Void getLength() const;

  inline bool isCreate() const;
  inline  ::capnp::Void getCreate() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FloatArrayOp::Builder {
public:
  typedef FloatArrayOp Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isConst32();
  inline bool hasConst32();
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder getConst32();
  inline void setConst32( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setConst32(::kj::ArrayPtr<const float> value);
  inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder initConst32(unsigned int size);
  inline void adoptConst32(::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> disownConst32();

  inline bool isConst64();
  inline bool hasConst64();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getConst64();
  inline void setConst64( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setConst64(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initConst64(unsigned int size);
  inline void adoptConst64(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownConst64();

  inline bool isZero();
  inline  ::jeff::FloatPrecision getZero();
  inline void setZero( ::jeff::FloatPrecision value);

  inline bool isGetIndex();
  inline  ::capnp::Void getGetIndex();
  inline void setGetIndex( ::capnp::Void value = ::capnp::VOID);

  inline bool isSetIndex();
  inline  ::capnp::Void getSetIndex();
  inline void setSetIndex( ::capnp::Void value = ::capnp::VOID);

  inline bool isLength();
  inline  ::capnp::Void getLength();
  inline void setLength( ::capnp::Void value = ::capnp::VOID);

  inline bool isCreate();
  inline  ::capnp::Void getCreate();
  inline void setCreate( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FloatArrayOp::Pipeline {
public:
  typedef FloatArrayOp Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ScfOp::Reader {
public:
  typedef ScfOp Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isSwitch() const;
  inline typename Switch::Reader getSwitch() const;

  inline bool isFor() const;
  inline bool hasFor() const;
  inline  ::jeff::Region::Reader getFor() const;

  inline bool isWhile() const;
  inline typename While::Reader getWhile() const;

  inline bool isDoWhile() const;
  inline typename DoWhile::Reader getDoWhile() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ScfOp::Builder {
public:
  typedef ScfOp Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isSwitch();
  inline typename Switch::Builder getSwitch();
  inline typename Switch::Builder initSwitch();

  inline bool isFor();
  inline bool hasFor();
  inline  ::jeff::Region::Builder getFor();
  inline void setFor( ::jeff::Region::Reader value);
  inline  ::jeff::Region::Builder initFor();
  inline void adoptFor(::capnp::Orphan< ::jeff::Region>&& value);
  inline ::capnp::Orphan< ::jeff::Region> disownFor();

  inline bool isWhile();
  inline typename While::Builder getWhile();
  inline typename While::Builder initWhile();

  inline bool isDoWhile();
  inline typename DoWhile::Builder getDoWhile();
  inline typename DoWhile::Builder initDoWhile();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ScfOp::Pipeline {
public:
  typedef ScfOp Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ScfOp::Switch::Reader {
public:
  typedef Switch Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBranches() const;
  inline  ::capnp::List< ::jeff::Region,  ::capnp::Kind::STRUCT>::Reader getBranches() const;

  inline bool hasDefault() const;
  inline  ::jeff::Region::Reader getDefault() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ScfOp::Switch::Builder {
public:
  typedef Switch Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBranches();
  inline  ::capnp::List< ::jeff::Region,  ::capnp::Kind::STRUCT>::Builder getBranches();
  inline void setBranches( ::capnp::List< ::jeff::Region,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::jeff::Region,  ::capnp::Kind::STRUCT>::Builder initBranches(unsigned int size);
  inline void adoptBranches(::capnp::Orphan< ::capnp::List< ::jeff::Region,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::jeff::Region,  ::capnp::Kind::STRUCT>> disownBranches();

  inline bool hasDefault();
  inline  ::jeff::Region::Builder getDefault();
  inline void setDefault( ::jeff::Region::Reader value);
  inline  ::jeff::Region::Builder initDefault();
  inline void adoptDefault(::capnp::Orphan< ::jeff::Region>&& value);
  inline ::capnp::Orphan< ::jeff::Region> disownDefault();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ScfOp::Switch::Pipeline {
public:
  typedef Switch Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::jeff::Region::Pipeline getDefault();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ScfOp::While::Reader {
public:
  typedef While Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCondition() const;
  inline  ::jeff::Region::Reader getCondition() const;

  inline bool hasBody() const;
  inline  ::jeff::Region::Reader getBody() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ScfOp::While::Builder {
public:
  typedef While Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCondition();
  inline  ::jeff::Region::Builder getCondition();
  inline void setCondition( ::jeff::Region::Reader value);
  inline  ::jeff::Region::Builder initCondition();
  inline void adoptCondition(::capnp::Orphan< ::jeff::Region>&& value);
  inline ::capnp::Orphan< ::jeff::Region> disownCondition();

  inline bool hasBody();
  inline  ::jeff::Region::Builder getBody();
  inline void setBody( ::jeff::Region::Reader value);
  inline  ::jeff::Region::Builder initBody();
  inline void adoptBody(::capnp::Orphan< ::jeff::Region>&& value);
  inline ::capnp::Orphan< ::jeff::Region> disownBody();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ScfOp::While::Pipeline {
public:
  typedef While Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::jeff::Region::Pipeline getCondition();
  inline  ::jeff::Region::Pipeline getBody();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ScfOp::DoWhile::Reader {
public:
  typedef DoWhile Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBody() const;
  inline  ::jeff::Region::Reader getBody() const;

  inline bool hasCondition() const;
  inline  ::jeff::Region::Reader getCondition() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ScfOp::DoWhile::Builder {
public:
  typedef DoWhile Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBody();
  inline  ::jeff::Region::Builder getBody();
  inline void setBody( ::jeff::Region::Reader value);
  inline  ::jeff::Region::Builder initBody();
  inline void adoptBody(::capnp::Orphan< ::jeff::Region>&& value);
  inline ::capnp::Orphan< ::jeff::Region> disownBody();

  inline bool hasCondition();
  inline  ::jeff::Region::Builder getCondition();
  inline void setCondition( ::jeff::Region::Reader value);
  inline  ::jeff::Region::Builder initCondition();
  inline void adoptCondition(::capnp::Orphan< ::jeff::Region>&& value);
  inline ::capnp::Orphan< ::jeff::Region> disownCondition();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ScfOp::DoWhile::Pipeline {
public:
  typedef DoWhile Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::jeff::Region::Pipeline getBody();
  inline  ::jeff::Region::Pipeline getCondition();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FuncOp::Reader {
public:
  typedef FuncOp Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getFuncCall() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class FuncOp::Builder {
public:
  typedef FuncOp Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getFuncCall();
  inline void setFuncCall( ::uint16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FuncOp::Pipeline {
public:
  typedef FuncOp Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::uint32_t Module::Reader::getVersion() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Module::Builder::getVersion() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Module::Builder::setVersion( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Module::Reader::hasFunctions() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasFunctions() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::jeff::Function,  ::capnp::Kind::STRUCT>::Reader Module::Reader::getFunctions() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Function,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::jeff::Function,  ::capnp::Kind::STRUCT>::Builder Module::Builder::getFunctions() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Function,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Module::Builder::setFunctions( ::capnp::List< ::jeff::Function,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Function,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::jeff::Function,  ::capnp::Kind::STRUCT>::Builder Module::Builder::initFunctions(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Function,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Module::Builder::adoptFunctions(
    ::capnp::Orphan< ::capnp::List< ::jeff::Function,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Function,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::jeff::Function,  ::capnp::Kind::STRUCT>> Module::Builder::disownFunctions() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Function,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Module::Reader::hasStrings() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasStrings() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader Module::Reader::getStrings() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Module::Builder::getStrings() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Module::Builder::setStrings( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void Module::Builder::setStrings(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Module::Builder::initStrings(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Module::Builder::adoptStrings(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> Module::Builder::disownStrings() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Module::Reader::hasMetadata() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasMetadata() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Reader Module::Reader::getMetadata() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Builder Module::Builder::getMetadata() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Module::Builder::setMetadata( ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Builder Module::Builder::initMetadata(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Module::Builder::adoptMetadata(
    ::capnp::Orphan< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>> Module::Builder::disownMetadata() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::uint16_t Module::Reader::getEntrypoint() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Module::Builder::getEntrypoint() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Module::Builder::setEntrypoint( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Module::Reader::hasTool() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasTool() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Module::Reader::getTool() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Module::Builder::getTool() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Module::Builder::setTool( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Module::Builder::initTool(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void Module::Builder::adoptTool(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Module::Builder::disownTool() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Module::Reader::hasToolVersion() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool Module::Builder::hasToolVersion() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Module::Reader::getToolVersion() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Module::Builder::getToolVersion() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void Module::Builder::setToolVersion( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Module::Builder::initToolVersion(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
inline void Module::Builder::adoptToolVersion(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Module::Builder::disownToolVersion() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline  ::jeff::Function::Which Function::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline  ::jeff::Function::Which Function::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Function::Reader::getName() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Function::Builder::getName() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Function::Builder::setName( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Function::Reader::isDefinition() const {
  return which() == Function::DEFINITION;
}
inline bool Function::Builder::isDefinition() {
  return which() == Function::DEFINITION;
}
inline typename Function::Definition::Reader Function::Reader::getDefinition() const {
  KJ_IREQUIRE((which() == Function::DEFINITION),
              "Must check which() before get()ing a union member.");
  return typename Function::Definition::Reader(_reader);
}
inline typename Function::Definition::Builder Function::Builder::getDefinition() {
  KJ_IREQUIRE((which() == Function::DEFINITION),
              "Must check which() before get()ing a union member.");
  return typename Function::Definition::Builder(_builder);
}
inline typename Function::Definition::Builder Function::Builder::initDefinition() {
  _builder.setDataField<Function::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Function::DEFINITION);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).clear();
  return typename Function::Definition::Builder(_builder);
}
inline bool Function::Reader::hasMetadata() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Function::Builder::hasMetadata() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Reader Function::Reader::getMetadata() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Builder Function::Builder::getMetadata() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Function::Builder::setMetadata( ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Builder Function::Builder::initMetadata(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Function::Builder::adoptMetadata(
    ::capnp::Orphan< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>> Function::Builder::disownMetadata() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Function::Reader::isDeclaration() const {
  return which() == Function::DECLARATION;
}
inline bool Function::Builder::isDeclaration() {
  return which() == Function::DECLARATION;
}
inline typename Function::Declaration::Reader Function::Reader::getDeclaration() const {
  KJ_IREQUIRE((which() == Function::DECLARATION),
              "Must check which() before get()ing a union member.");
  return typename Function::Declaration::Reader(_reader);
}
inline typename Function::Declaration::Builder Function::Builder::getDeclaration() {
  KJ_IREQUIRE((which() == Function::DECLARATION),
              "Must check which() before get()ing a union member.");
  return typename Function::Declaration::Builder(_builder);
}
inline typename Function::Declaration::Builder Function::Builder::initDeclaration() {
  _builder.setDataField<Function::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, Function::DECLARATION);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).clear();
  return typename Function::Declaration::Builder(_builder);
}
inline bool Function::Definition::Reader::hasBody() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Function::Definition::Builder::hasBody() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::jeff::Region::Reader Function::Definition::Reader::getBody() const {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::jeff::Region::Builder Function::Definition::Builder::getBody() {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::jeff::Region::Pipeline Function::Definition::Pipeline::getBody() {
  return  ::jeff::Region::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Function::Definition::Builder::setBody( ::jeff::Region::Reader value) {
  ::capnp::_::PointerHelpers< ::jeff::Region>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::jeff::Region::Builder Function::Definition::Builder::initBody() {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Function::Definition::Builder::adoptBody(
    ::capnp::Orphan< ::jeff::Region>&& value) {
  ::capnp::_::PointerHelpers< ::jeff::Region>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::jeff::Region> Function::Definition::Builder::disownBody() {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Function::Definition::Reader::hasValues() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Function::Definition::Builder::hasValues() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Reader Function::Definition::Reader::getValues() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Builder Function::Definition::Builder::getValues() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Function::Definition::Builder::setValues( ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Builder Function::Definition::Builder::initValues(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Function::Definition::Builder::adoptValues(
    ::capnp::Orphan< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>> Function::Definition::Builder::disownValues() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Function::Declaration::Reader::hasInputs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Function::Declaration::Builder::hasInputs() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Reader Function::Declaration::Reader::getInputs() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Builder Function::Declaration::Builder::getInputs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Function::Declaration::Builder::setInputs( ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Builder Function::Declaration::Builder::initInputs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Function::Declaration::Builder::adoptInputs(
    ::capnp::Orphan< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>> Function::Declaration::Builder::disownInputs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Function::Declaration::Reader::hasOutputs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Function::Declaration::Builder::hasOutputs() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Reader Function::Declaration::Reader::getOutputs() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Builder Function::Declaration::Builder::getOutputs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Function::Declaration::Builder::setOutputs( ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>::Builder Function::Declaration::Builder::initOutputs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Function::Declaration::Builder::adoptOutputs(
    ::capnp::Orphan< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>> Function::Declaration::Builder::disownOutputs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Value,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Region::Reader::hasSources() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Region::Builder::hasSources() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader Region::Reader::getSources() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Region::Builder::getSources() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Region::Builder::setSources( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Region::Builder::setSources(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Region::Builder::initSources(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Region::Builder::adoptSources(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> Region::Builder::disownSources() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Region::Reader::hasTargets() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Region::Builder::hasTargets() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader Region::Reader::getTargets() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Region::Builder::getTargets() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Region::Builder::setTargets( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void Region::Builder::setTargets(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Region::Builder::initTargets(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Region::Builder::adoptTargets(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> Region::Builder::disownTargets() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Region::Reader::hasOperations() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Region::Builder::hasOperations() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::jeff::Op,  ::capnp::Kind::STRUCT>::Reader Region::Reader::getOperations() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Op,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::jeff::Op,  ::capnp::Kind::STRUCT>::Builder Region::Builder::getOperations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Op,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Region::Builder::setOperations( ::capnp::List< ::jeff::Op,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Op,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::jeff::Op,  ::capnp::Kind::STRUCT>::Builder Region::Builder::initOperations(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Op,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Region::Builder::adoptOperations(
    ::capnp::Orphan< ::capnp::List< ::jeff::Op,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Op,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::jeff::Op,  ::capnp::Kind::STRUCT>> Region::Builder::disownOperations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Op,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Region::Reader::hasMetadata() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Region::Builder::hasMetadata() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Reader Region::Reader::getMetadata() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Builder Region::Builder::getMetadata() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Region::Builder::setMetadata( ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Builder Region::Builder::initMetadata(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void Region::Builder::adoptMetadata(
    ::capnp::Orphan< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>> Region::Builder::disownMetadata() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Op::Reader::hasInputs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Op::Builder::hasInputs() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader Op::Reader::getInputs() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Op::Builder::getInputs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Op::Builder::setInputs( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void Op::Builder::setInputs(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Op::Builder::initInputs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Op::Builder::adoptInputs(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> Op::Builder::disownInputs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Op::Reader::hasOutputs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Op::Builder::hasOutputs() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader Op::Reader::getOutputs() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Op::Builder::getOutputs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Op::Builder::setOutputs( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void Op::Builder::setOutputs(::kj::ArrayPtr<const  ::uint32_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder Op::Builder::initOutputs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Op::Builder::adoptOutputs(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> Op::Builder::disownOutputs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Op::Reader::hasMetadata() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Op::Builder::hasMetadata() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Reader Op::Reader::getMetadata() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Builder Op::Builder::getMetadata() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Op::Builder::setMetadata( ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Builder Op::Builder::initMetadata(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Op::Builder::adoptMetadata(
    ::capnp::Orphan< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>> Op::Builder::disownMetadata() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline typename Op::Instruction::Reader Op::Reader::getInstruction() const {
  return typename Op::Instruction::Reader(_reader);
}
inline typename Op::Instruction::Builder Op::Builder::getInstruction() {
  return typename Op::Instruction::Builder(_builder);
}
#if !CAPNP_LITE
inline typename Op::Instruction::Pipeline Op::Pipeline::getInstruction() {
  return typename Op::Instruction::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename Op::Instruction::Builder Op::Builder::initInstruction() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<3>() * ::capnp::POINTERS).clear();
  return typename Op::Instruction::Builder(_builder);
}
inline  ::jeff::Op::Instruction::Which Op::Instruction::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::jeff::Op::Instruction::Which Op::Instruction::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Op::Instruction::Reader::isQubit() const {
  return which() == Op::Instruction::QUBIT;
}
inline bool Op::Instruction::Builder::isQubit() {
  return which() == Op::Instruction::QUBIT;
}
inline bool Op::Instruction::Reader::hasQubit() const {
  if (which() != Op::Instruction::QUBIT) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Op::Instruction::Builder::hasQubit() {
  if (which() != Op::Instruction::QUBIT) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::jeff::QubitOp::Reader Op::Instruction::Reader::getQubit() const {
  KJ_IREQUIRE((which() == Op::Instruction::QUBIT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::QubitOp>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::jeff::QubitOp::Builder Op::Instruction::Builder::getQubit() {
  KJ_IREQUIRE((which() == Op::Instruction::QUBIT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::QubitOp>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Op::Instruction::Builder::setQubit( ::jeff::QubitOp::Reader value) {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::QUBIT);
  ::capnp::_::PointerHelpers< ::jeff::QubitOp>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::jeff::QubitOp::Builder Op::Instruction::Builder::initQubit() {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::QUBIT);
  return ::capnp::_::PointerHelpers< ::jeff::QubitOp>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Op::Instruction::Builder::adoptQubit(
    ::capnp::Orphan< ::jeff::QubitOp>&& value) {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::QUBIT);
  ::capnp::_::PointerHelpers< ::jeff::QubitOp>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::jeff::QubitOp> Op::Instruction::Builder::disownQubit() {
  KJ_IREQUIRE((which() == Op::Instruction::QUBIT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::QubitOp>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Op::Instruction::Reader::isQureg() const {
  return which() == Op::Instruction::QUREG;
}
inline bool Op::Instruction::Builder::isQureg() {
  return which() == Op::Instruction::QUREG;
}
inline bool Op::Instruction::Reader::hasQureg() const {
  if (which() != Op::Instruction::QUREG) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Op::Instruction::Builder::hasQureg() {
  if (which() != Op::Instruction::QUREG) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::jeff::QuregOp::Reader Op::Instruction::Reader::getQureg() const {
  KJ_IREQUIRE((which() == Op::Instruction::QUREG),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::QuregOp>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::jeff::QuregOp::Builder Op::Instruction::Builder::getQureg() {
  KJ_IREQUIRE((which() == Op::Instruction::QUREG),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::QuregOp>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Op::Instruction::Builder::setQureg( ::jeff::QuregOp::Reader value) {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::QUREG);
  ::capnp::_::PointerHelpers< ::jeff::QuregOp>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::jeff::QuregOp::Builder Op::Instruction::Builder::initQureg() {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::QUREG);
  return ::capnp::_::PointerHelpers< ::jeff::QuregOp>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Op::Instruction::Builder::adoptQureg(
    ::capnp::Orphan< ::jeff::QuregOp>&& value) {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::QUREG);
  ::capnp::_::PointerHelpers< ::jeff::QuregOp>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::jeff::QuregOp> Op::Instruction::Builder::disownQureg() {
  KJ_IREQUIRE((which() == Op::Instruction::QUREG),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::QuregOp>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Op::Instruction::Reader::isInt() const {
  return which() == Op::Instruction::INT;
}
inline bool Op::Instruction::Builder::isInt() {
  return which() == Op::Instruction::INT;
}
inline bool Op::Instruction::Reader::hasInt() const {
  if (which() != Op::Instruction::INT) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Op::Instruction::Builder::hasInt() {
  if (which() != Op::Instruction::INT) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::jeff::IntOp::Reader Op::Instruction::Reader::getInt() const {
  KJ_IREQUIRE((which() == Op::Instruction::INT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::IntOp>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::jeff::IntOp::Builder Op::Instruction::Builder::getInt() {
  KJ_IREQUIRE((which() == Op::Instruction::INT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::IntOp>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Op::Instruction::Builder::setInt( ::jeff::IntOp::Reader value) {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::INT);
  ::capnp::_::PointerHelpers< ::jeff::IntOp>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::jeff::IntOp::Builder Op::Instruction::Builder::initInt() {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::INT);
  return ::capnp::_::PointerHelpers< ::jeff::IntOp>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Op::Instruction::Builder::adoptInt(
    ::capnp::Orphan< ::jeff::IntOp>&& value) {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::INT);
  ::capnp::_::PointerHelpers< ::jeff::IntOp>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::jeff::IntOp> Op::Instruction::Builder::disownInt() {
  KJ_IREQUIRE((which() == Op::Instruction::INT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::IntOp>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Op::Instruction::Reader::isIntArray() const {
  return which() == Op::Instruction::INT_ARRAY;
}
inline bool Op::Instruction::Builder::isIntArray() {
  return which() == Op::Instruction::INT_ARRAY;
}
inline bool Op::Instruction::Reader::hasIntArray() const {
  if (which() != Op::Instruction::INT_ARRAY) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Op::Instruction::Builder::hasIntArray() {
  if (which() != Op::Instruction::INT_ARRAY) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::jeff::IntArrayOp::Reader Op::Instruction::Reader::getIntArray() const {
  KJ_IREQUIRE((which() == Op::Instruction::INT_ARRAY),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::IntArrayOp>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::jeff::IntArrayOp::Builder Op::Instruction::Builder::getIntArray() {
  KJ_IREQUIRE((which() == Op::Instruction::INT_ARRAY),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::IntArrayOp>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Op::Instruction::Builder::setIntArray( ::jeff::IntArrayOp::Reader value) {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::INT_ARRAY);
  ::capnp::_::PointerHelpers< ::jeff::IntArrayOp>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::jeff::IntArrayOp::Builder Op::Instruction::Builder::initIntArray() {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::INT_ARRAY);
  return ::capnp::_::PointerHelpers< ::jeff::IntArrayOp>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Op::Instruction::Builder::adoptIntArray(
    ::capnp::Orphan< ::jeff::IntArrayOp>&& value) {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::INT_ARRAY);
  ::capnp::_::PointerHelpers< ::jeff::IntArrayOp>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::jeff::IntArrayOp> Op::Instruction::Builder::disownIntArray() {
  KJ_IREQUIRE((which() == Op::Instruction::INT_ARRAY),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::IntArrayOp>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Op::Instruction::Reader::isFloat() const {
  return which() == Op::Instruction::FLOAT;
}
inline bool Op::Instruction::Builder::isFloat() {
  return which() == Op::Instruction::FLOAT;
}
inline bool Op::Instruction::Reader::hasFloat() const {
  if (which() != Op::Instruction::FLOAT) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Op::Instruction::Builder::hasFloat() {
  if (which() != Op::Instruction::FLOAT) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::jeff::FloatOp::Reader Op::Instruction::Reader::getFloat() const {
  KJ_IREQUIRE((which() == Op::Instruction::FLOAT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::FloatOp>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::jeff::FloatOp::Builder Op::Instruction::Builder::getFloat() {
  KJ_IREQUIRE((which() == Op::Instruction::FLOAT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::FloatOp>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Op::Instruction::Builder::setFloat( ::jeff::FloatOp::Reader value) {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::FLOAT);
  ::capnp::_::PointerHelpers< ::jeff::FloatOp>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::jeff::FloatOp::Builder Op::Instruction::Builder::initFloat() {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::FLOAT);
  return ::capnp::_::PointerHelpers< ::jeff::FloatOp>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Op::Instruction::Builder::adoptFloat(
    ::capnp::Orphan< ::jeff::FloatOp>&& value) {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::FLOAT);
  ::capnp::_::PointerHelpers< ::jeff::FloatOp>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::jeff::FloatOp> Op::Instruction::Builder::disownFloat() {
  KJ_IREQUIRE((which() == Op::Instruction::FLOAT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::FloatOp>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Op::Instruction::Reader::isFloatArray() const {
  return which() == Op::Instruction::FLOAT_ARRAY;
}
inline bool Op::Instruction::Builder::isFloatArray() {
  return which() == Op::Instruction::FLOAT_ARRAY;
}
inline bool Op::Instruction::Reader::hasFloatArray() const {
  if (which() != Op::Instruction::FLOAT_ARRAY) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Op::Instruction::Builder::hasFloatArray() {
  if (which() != Op::Instruction::FLOAT_ARRAY) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::jeff::FloatArrayOp::Reader Op::Instruction::Reader::getFloatArray() const {
  KJ_IREQUIRE((which() == Op::Instruction::FLOAT_ARRAY),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::FloatArrayOp>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::jeff::FloatArrayOp::Builder Op::Instruction::Builder::getFloatArray() {
  KJ_IREQUIRE((which() == Op::Instruction::FLOAT_ARRAY),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::FloatArrayOp>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Op::Instruction::Builder::setFloatArray( ::jeff::FloatArrayOp::Reader value) {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::FLOAT_ARRAY);
  ::capnp::_::PointerHelpers< ::jeff::FloatArrayOp>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::jeff::FloatArrayOp::Builder Op::Instruction::Builder::initFloatArray() {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::FLOAT_ARRAY);
  return ::capnp::_::PointerHelpers< ::jeff::FloatArrayOp>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Op::Instruction::Builder::adoptFloatArray(
    ::capnp::Orphan< ::jeff::FloatArrayOp>&& value) {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::FLOAT_ARRAY);
  ::capnp::_::PointerHelpers< ::jeff::FloatArrayOp>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::jeff::FloatArrayOp> Op::Instruction::Builder::disownFloatArray() {
  KJ_IREQUIRE((which() == Op::Instruction::FLOAT_ARRAY),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::FloatArrayOp>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Op::Instruction::Reader::isScf() const {
  return which() == Op::Instruction::SCF;
}
inline bool Op::Instruction::Builder::isScf() {
  return which() == Op::Instruction::SCF;
}
inline bool Op::Instruction::Reader::hasScf() const {
  if (which() != Op::Instruction::SCF) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Op::Instruction::Builder::hasScf() {
  if (which() != Op::Instruction::SCF) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::jeff::ScfOp::Reader Op::Instruction::Reader::getScf() const {
  KJ_IREQUIRE((which() == Op::Instruction::SCF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::ScfOp>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::jeff::ScfOp::Builder Op::Instruction::Builder::getScf() {
  KJ_IREQUIRE((which() == Op::Instruction::SCF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::ScfOp>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Op::Instruction::Builder::setScf( ::jeff::ScfOp::Reader value) {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::SCF);
  ::capnp::_::PointerHelpers< ::jeff::ScfOp>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::jeff::ScfOp::Builder Op::Instruction::Builder::initScf() {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::SCF);
  return ::capnp::_::PointerHelpers< ::jeff::ScfOp>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Op::Instruction::Builder::adoptScf(
    ::capnp::Orphan< ::jeff::ScfOp>&& value) {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::SCF);
  ::capnp::_::PointerHelpers< ::jeff::ScfOp>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::jeff::ScfOp> Op::Instruction::Builder::disownScf() {
  KJ_IREQUIRE((which() == Op::Instruction::SCF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::ScfOp>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Op::Instruction::Reader::isFunc() const {
  return which() == Op::Instruction::FUNC;
}
inline bool Op::Instruction::Builder::isFunc() {
  return which() == Op::Instruction::FUNC;
}
inline bool Op::Instruction::Reader::hasFunc() const {
  if (which() != Op::Instruction::FUNC) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Op::Instruction::Builder::hasFunc() {
  if (which() != Op::Instruction::FUNC) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::jeff::FuncOp::Reader Op::Instruction::Reader::getFunc() const {
  KJ_IREQUIRE((which() == Op::Instruction::FUNC),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::FuncOp>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::jeff::FuncOp::Builder Op::Instruction::Builder::getFunc() {
  KJ_IREQUIRE((which() == Op::Instruction::FUNC),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::FuncOp>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Op::Instruction::Builder::setFunc( ::jeff::FuncOp::Reader value) {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::FUNC);
  ::capnp::_::PointerHelpers< ::jeff::FuncOp>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::jeff::FuncOp::Builder Op::Instruction::Builder::initFunc() {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::FUNC);
  return ::capnp::_::PointerHelpers< ::jeff::FuncOp>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Op::Instruction::Builder::adoptFunc(
    ::capnp::Orphan< ::jeff::FuncOp>&& value) {
  _builder.setDataField<Op::Instruction::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Op::Instruction::FUNC);
  ::capnp::_::PointerHelpers< ::jeff::FuncOp>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::jeff::FuncOp> Op::Instruction::Builder::disownFunc() {
  KJ_IREQUIRE((which() == Op::Instruction::FUNC),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::FuncOp>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Value::Reader::hasType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Value::Builder::hasType() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::jeff::Type::Reader Value::Reader::getType() const {
  return ::capnp::_::PointerHelpers< ::jeff::Type>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::jeff::Type::Builder Value::Builder::getType() {
  return ::capnp::_::PointerHelpers< ::jeff::Type>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::jeff::Type::Pipeline Value::Pipeline::getType() {
  return  ::jeff::Type::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Value::Builder::setType( ::jeff::Type::Reader value) {
  ::capnp::_::PointerHelpers< ::jeff::Type>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::jeff::Type::Builder Value::Builder::initType() {
  return ::capnp::_::PointerHelpers< ::jeff::Type>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Value::Builder::adoptType(
    ::capnp::Orphan< ::jeff::Type>&& value) {
  ::capnp::_::PointerHelpers< ::jeff::Type>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::jeff::Type> Value::Builder::disownType() {
  return ::capnp::_::PointerHelpers< ::jeff::Type>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Value::Reader::hasMetadata() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Value::Builder::hasMetadata() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Reader Value::Reader::getMetadata() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Builder Value::Builder::getMetadata() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Value::Builder::setMetadata( ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>::Builder Value::Builder::initMetadata(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Value::Builder::adoptMetadata(
    ::capnp::Orphan< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>> Value::Builder::disownMetadata() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Meta,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::jeff::Type::Which Type::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::jeff::Type::Which Type::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Type::Reader::isQubit() const {
  return which() == Type::QUBIT;
}
inline bool Type::Builder::isQubit() {
  return which() == Type::QUBIT;
}
inline  ::capnp::Void Type::Reader::getQubit() const {
  KJ_IREQUIRE((which() == Type::QUBIT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Type::Builder::getQubit() {
  KJ_IREQUIRE((which() == Type::QUBIT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Type::Builder::setQubit( ::capnp::Void value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::QUBIT);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Reader::isQureg() const {
  return which() == Type::QUREG;
}
inline bool Type::Builder::isQureg() {
  return which() == Type::QUREG;
}
inline  ::capnp::Void Type::Reader::getQureg() const {
  KJ_IREQUIRE((which() == Type::QUREG),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Type::Builder::getQureg() {
  KJ_IREQUIRE((which() == Type::QUREG),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Type::Builder::setQureg( ::capnp::Void value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::QUREG);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Reader::isInt() const {
  return which() == Type::INT;
}
inline bool Type::Builder::isInt() {
  return which() == Type::INT;
}
inline  ::uint8_t Type::Reader::getInt() const {
  KJ_IREQUIRE((which() == Type::INT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Type::Builder::getInt() {
  KJ_IREQUIRE((which() == Type::INT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Type::Builder::setInt( ::uint8_t value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::INT);
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Reader::isIntArray() const {
  return which() == Type::INT_ARRAY;
}
inline bool Type::Builder::isIntArray() {
  return which() == Type::INT_ARRAY;
}
inline  ::uint8_t Type::Reader::getIntArray() const {
  KJ_IREQUIRE((which() == Type::INT_ARRAY),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Type::Builder::getIntArray() {
  KJ_IREQUIRE((which() == Type::INT_ARRAY),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Type::Builder::setIntArray( ::uint8_t value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::INT_ARRAY);
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Reader::isFloat() const {
  return which() == Type::FLOAT;
}
inline bool Type::Builder::isFloat() {
  return which() == Type::FLOAT;
}
inline  ::jeff::FloatPrecision Type::Reader::getFloat() const {
  KJ_IREQUIRE((which() == Type::FLOAT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::jeff::FloatPrecision>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::jeff::FloatPrecision Type::Builder::getFloat() {
  KJ_IREQUIRE((which() == Type::FLOAT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::jeff::FloatPrecision>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Type::Builder::setFloat( ::jeff::FloatPrecision value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::FLOAT);
  _builder.setDataField< ::jeff::FloatPrecision>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Reader::isFloatArray() const {
  return which() == Type::FLOAT_ARRAY;
}
inline bool Type::Builder::isFloatArray() {
  return which() == Type::FLOAT_ARRAY;
}
inline  ::jeff::FloatPrecision Type::Reader::getFloatArray() const {
  KJ_IREQUIRE((which() == Type::FLOAT_ARRAY),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::jeff::FloatPrecision>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::jeff::FloatPrecision Type::Builder::getFloatArray() {
  KJ_IREQUIRE((which() == Type::FLOAT_ARRAY),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::jeff::FloatPrecision>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Type::Builder::setFloatArray( ::jeff::FloatPrecision value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::FLOAT_ARRAY);
  _builder.setDataField< ::jeff::FloatPrecision>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t Meta::Reader::getName() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Meta::Builder::getName() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Meta::Builder::setName( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Meta::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Meta::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::AnyPointer::Reader Meta::Reader::getValue() const {
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder Meta::Builder::getValue() {
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::AnyPointer::Builder Meta::Builder::initValue() {
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

inline  ::jeff::QubitOp::Which QubitOp::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::jeff::QubitOp::Which QubitOp::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool QubitOp::Reader::isAlloc() const {
  return which() == QubitOp::ALLOC;
}
inline bool QubitOp::Builder::isAlloc() {
  return which() == QubitOp::ALLOC;
}
inline  ::capnp::Void QubitOp::Reader::getAlloc() const {
  KJ_IREQUIRE((which() == QubitOp::ALLOC),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void QubitOp::Builder::getAlloc() {
  KJ_IREQUIRE((which() == QubitOp::ALLOC),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void QubitOp::Builder::setAlloc( ::capnp::Void value) {
  _builder.setDataField<QubitOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, QubitOp::ALLOC);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool QubitOp::Reader::isFree() const {
  return which() == QubitOp::FREE;
}
inline bool QubitOp::Builder::isFree() {
  return which() == QubitOp::FREE;
}
inline  ::capnp::Void QubitOp::Reader::getFree() const {
  KJ_IREQUIRE((which() == QubitOp::FREE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void QubitOp::Builder::getFree() {
  KJ_IREQUIRE((which() == QubitOp::FREE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void QubitOp::Builder::setFree( ::capnp::Void value) {
  _builder.setDataField<QubitOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, QubitOp::FREE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool QubitOp::Reader::isFreeZero() const {
  return which() == QubitOp::FREE_ZERO;
}
inline bool QubitOp::Builder::isFreeZero() {
  return which() == QubitOp::FREE_ZERO;
}
inline  ::capnp::Void QubitOp::Reader::getFreeZero() const {
  KJ_IREQUIRE((which() == QubitOp::FREE_ZERO),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void QubitOp::Builder::getFreeZero() {
  KJ_IREQUIRE((which() == QubitOp::FREE_ZERO),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void QubitOp::Builder::setFreeZero( ::capnp::Void value) {
  _builder.setDataField<QubitOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, QubitOp::FREE_ZERO);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool QubitOp::Reader::isMeasure() const {
  return which() == QubitOp::MEASURE;
}
inline bool QubitOp::Builder::isMeasure() {
  return which() == QubitOp::MEASURE;
}
inline  ::capnp::Void QubitOp::Reader::getMeasure() const {
  KJ_IREQUIRE((which() == QubitOp::MEASURE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void QubitOp::Builder::getMeasure() {
  KJ_IREQUIRE((which() == QubitOp::MEASURE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void QubitOp::Builder::setMeasure( ::capnp::Void value) {
  _builder.setDataField<QubitOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, QubitOp::MEASURE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool QubitOp::Reader::isMeasureNd() const {
  return which() == QubitOp::MEASURE_ND;
}
inline bool QubitOp::Builder::isMeasureNd() {
  return which() == QubitOp::MEASURE_ND;
}
inline  ::capnp::Void QubitOp::Reader::getMeasureNd() const {
  KJ_IREQUIRE((which() == QubitOp::MEASURE_ND),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void QubitOp::Builder::getMeasureNd() {
  KJ_IREQUIRE((which() == QubitOp::MEASURE_ND),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void QubitOp::Builder::setMeasureNd( ::capnp::Void value) {
  _builder.setDataField<QubitOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, QubitOp::MEASURE_ND);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool QubitOp::Reader::isReset() const {
  return which() == QubitOp::RESET;
}
inline bool QubitOp::Builder::isReset() {
  return which() == QubitOp::RESET;
}
inline  ::capnp::Void QubitOp::Reader::getReset() const {
  KJ_IREQUIRE((which() == QubitOp::RESET),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void QubitOp::Builder::getReset() {
  KJ_IREQUIRE((which() == QubitOp::RESET),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void QubitOp::Builder::setReset( ::capnp::Void value) {
  _builder.setDataField<QubitOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, QubitOp::RESET);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool QubitOp::Reader::isGate() const {
  return which() == QubitOp::GATE;
}
inline bool QubitOp::Builder::isGate() {
  return which() == QubitOp::GATE;
}
inline bool QubitOp::Reader::hasGate() const {
  if (which() != QubitOp::GATE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool QubitOp::Builder::hasGate() {
  if (which() != QubitOp::GATE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::jeff::QubitGate::Reader QubitOp::Reader::getGate() const {
  KJ_IREQUIRE((which() == QubitOp::GATE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::QubitGate>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::jeff::QubitGate::Builder QubitOp::Builder::getGate() {
  KJ_IREQUIRE((which() == QubitOp::GATE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::QubitGate>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void QubitOp::Builder::setGate( ::jeff::QubitGate::Reader value) {
  _builder.setDataField<QubitOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, QubitOp::GATE);
  ::capnp::_::PointerHelpers< ::jeff::QubitGate>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::jeff::QubitGate::Builder QubitOp::Builder::initGate() {
  _builder.setDataField<QubitOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, QubitOp::GATE);
  return ::capnp::_::PointerHelpers< ::jeff::QubitGate>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void QubitOp::Builder::adoptGate(
    ::capnp::Orphan< ::jeff::QubitGate>&& value) {
  _builder.setDataField<QubitOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, QubitOp::GATE);
  ::capnp::_::PointerHelpers< ::jeff::QubitGate>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::jeff::QubitGate> QubitOp::Builder::disownGate() {
  KJ_IREQUIRE((which() == QubitOp::GATE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::QubitGate>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::jeff::QubitGate::Which QubitGate::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline  ::jeff::QubitGate::Which QubitGate::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool QubitGate::Reader::isWellKnown() const {
  return which() == QubitGate::WELL_KNOWN;
}
inline bool QubitGate::Builder::isWellKnown() {
  return which() == QubitGate::WELL_KNOWN;
}
inline  ::jeff::WellKnownGate QubitGate::Reader::getWellKnown() const {
  KJ_IREQUIRE((which() == QubitGate::WELL_KNOWN),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::jeff::WellKnownGate>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::jeff::WellKnownGate QubitGate::Builder::getWellKnown() {
  KJ_IREQUIRE((which() == QubitGate::WELL_KNOWN),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::jeff::WellKnownGate>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void QubitGate::Builder::setWellKnown( ::jeff::WellKnownGate value) {
  _builder.setDataField<QubitGate::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, QubitGate::WELL_KNOWN);
  _builder.setDataField< ::jeff::WellKnownGate>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool QubitGate::Reader::isCustom() const {
  return which() == QubitGate::CUSTOM;
}
inline bool QubitGate::Builder::isCustom() {
  return which() == QubitGate::CUSTOM;
}
inline typename QubitGate::Custom::Reader QubitGate::Reader::getCustom() const {
  KJ_IREQUIRE((which() == QubitGate::CUSTOM),
              "Must check which() before get()ing a union member.");
  return typename QubitGate::Custom::Reader(_reader);
}
inline typename QubitGate::Custom::Builder QubitGate::Builder::getCustom() {
  KJ_IREQUIRE((which() == QubitGate::CUSTOM),
              "Must check which() before get()ing a union member.");
  return typename QubitGate::Custom::Builder(_builder);
}
inline typename QubitGate::Custom::Builder QubitGate::Builder::initCustom() {
  _builder.setDataField<QubitGate::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, QubitGate::CUSTOM);
  _builder.setDataField< ::uint16_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint8_t>(::capnp::bounded<4>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint8_t>(::capnp::bounded<5>() * ::capnp::ELEMENTS, 0);
  return typename QubitGate::Custom::Builder(_builder);
}
inline  ::uint8_t QubitGate::Reader::getControlQubits() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t QubitGate::Builder::getControlQubits() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void QubitGate::Builder::setControlQubits( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline bool QubitGate::Reader::getAdjoint() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<56>() * ::capnp::ELEMENTS);
}

inline bool QubitGate::Builder::getAdjoint() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<56>() * ::capnp::ELEMENTS);
}
inline void QubitGate::Builder::setAdjoint(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<56>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t QubitGate::Reader::getPower() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t QubitGate::Builder::getPower() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS);
}
inline void QubitGate::Builder::setPower( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<8>() * ::capnp::ELEMENTS, value);
}

inline bool QubitGate::Reader::isPpr() const {
  return which() == QubitGate::PPR;
}
inline bool QubitGate::Builder::isPpr() {
  return which() == QubitGate::PPR;
}
inline typename QubitGate::Ppr::Reader QubitGate::Reader::getPpr() const {
  KJ_IREQUIRE((which() == QubitGate::PPR),
              "Must check which() before get()ing a union member.");
  return typename QubitGate::Ppr::Reader(_reader);
}
inline typename QubitGate::Ppr::Builder QubitGate::Builder::getPpr() {
  KJ_IREQUIRE((which() == QubitGate::PPR),
              "Must check which() before get()ing a union member.");
  return typename QubitGate::Ppr::Builder(_builder);
}
inline typename QubitGate::Ppr::Builder QubitGate::Builder::initPpr() {
  _builder.setDataField<QubitGate::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, QubitGate::PPR);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename QubitGate::Ppr::Builder(_builder);
}
inline  ::uint16_t QubitGate::Custom::Reader::getName() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t QubitGate::Custom::Builder::getName() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void QubitGate::Custom::Builder::setName( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t QubitGate::Custom::Reader::getNumQubits() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t QubitGate::Custom::Builder::getNumQubits() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void QubitGate::Custom::Builder::setNumQubits( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t QubitGate::Custom::Reader::getNumParams() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t QubitGate::Custom::Builder::getNumParams() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void QubitGate::Custom::Builder::setNumParams( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline bool QubitGate::Ppr::Reader::hasPauliString() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool QubitGate::Ppr::Builder::hasPauliString() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::jeff::Pauli,  ::capnp::Kind::ENUM>::Reader QubitGate::Ppr::Reader::getPauliString() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Pauli,  ::capnp::Kind::ENUM>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::jeff::Pauli,  ::capnp::Kind::ENUM>::Builder QubitGate::Ppr::Builder::getPauliString() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Pauli,  ::capnp::Kind::ENUM>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void QubitGate::Ppr::Builder::setPauliString( ::capnp::List< ::jeff::Pauli,  ::capnp::Kind::ENUM>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Pauli,  ::capnp::Kind::ENUM>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void QubitGate::Ppr::Builder::setPauliString(::kj::ArrayPtr<const  ::jeff::Pauli> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Pauli,  ::capnp::Kind::ENUM>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::jeff::Pauli,  ::capnp::Kind::ENUM>::Builder QubitGate::Ppr::Builder::initPauliString(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Pauli,  ::capnp::Kind::ENUM>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void QubitGate::Ppr::Builder::adoptPauliString(
    ::capnp::Orphan< ::capnp::List< ::jeff::Pauli,  ::capnp::Kind::ENUM>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Pauli,  ::capnp::Kind::ENUM>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::jeff::Pauli,  ::capnp::Kind::ENUM>> QubitGate::Ppr::Builder::disownPauliString() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Pauli,  ::capnp::Kind::ENUM>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::jeff::QuregOp::Which QuregOp::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::jeff::QuregOp::Which QuregOp::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool QuregOp::Reader::isAlloc() const {
  return which() == QuregOp::ALLOC;
}
inline bool QuregOp::Builder::isAlloc() {
  return which() == QuregOp::ALLOC;
}
inline  ::capnp::Void QuregOp::Reader::getAlloc() const {
  KJ_IREQUIRE((which() == QuregOp::ALLOC),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void QuregOp::Builder::getAlloc() {
  KJ_IREQUIRE((which() == QuregOp::ALLOC),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void QuregOp::Builder::setAlloc( ::capnp::Void value) {
  _builder.setDataField<QuregOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, QuregOp::ALLOC);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool QuregOp::Reader::isFreeZero() const {
  return which() == QuregOp::FREE_ZERO;
}
inline bool QuregOp::Builder::isFreeZero() {
  return which() == QuregOp::FREE_ZERO;
}
inline  ::capnp::Void QuregOp::Reader::getFreeZero() const {
  KJ_IREQUIRE((which() == QuregOp::FREE_ZERO),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void QuregOp::Builder::getFreeZero() {
  KJ_IREQUIRE((which() == QuregOp::FREE_ZERO),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void QuregOp::Builder::setFreeZero( ::capnp::Void value) {
  _builder.setDataField<QuregOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, QuregOp::FREE_ZERO);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool QuregOp::Reader::isExtractIndex() const {
  return which() == QuregOp::EXTRACT_INDEX;
}
inline bool QuregOp::Builder::isExtractIndex() {
  return which() == QuregOp::EXTRACT_INDEX;
}
inline  ::capnp::Void QuregOp::Reader::getExtractIndex() const {
  KJ_IREQUIRE((which() == QuregOp::EXTRACT_INDEX),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void QuregOp::Builder::getExtractIndex() {
  KJ_IREQUIRE((which() == QuregOp::EXTRACT_INDEX),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void QuregOp::Builder::setExtractIndex( ::capnp::Void value) {
  _builder.setDataField<QuregOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, QuregOp::EXTRACT_INDEX);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool QuregOp::Reader::isInsertIndex() const {
  return which() == QuregOp::INSERT_INDEX;
}
inline bool QuregOp::Builder::isInsertIndex() {
  return which() == QuregOp::INSERT_INDEX;
}
inline  ::capnp::Void QuregOp::Reader::getInsertIndex() const {
  KJ_IREQUIRE((which() == QuregOp::INSERT_INDEX),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void QuregOp::Builder::getInsertIndex() {
  KJ_IREQUIRE((which() == QuregOp::INSERT_INDEX),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void QuregOp::Builder::setInsertIndex( ::capnp::Void value) {
  _builder.setDataField<QuregOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, QuregOp::INSERT_INDEX);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool QuregOp::Reader::isExtractSlice() const {
  return which() == QuregOp::EXTRACT_SLICE;
}
inline bool QuregOp::Builder::isExtractSlice() {
  return which() == QuregOp::EXTRACT_SLICE;
}
inline  ::capnp::Void QuregOp::Reader::getExtractSlice() const {
  KJ_IREQUIRE((which() == QuregOp::EXTRACT_SLICE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void QuregOp::Builder::getExtractSlice() {
  KJ_IREQUIRE((which() == QuregOp::EXTRACT_SLICE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void QuregOp::Builder::setExtractSlice( ::capnp::Void value) {
  _builder.setDataField<QuregOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, QuregOp::EXTRACT_SLICE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool QuregOp::Reader::isInsertSlice() const {
  return which() == QuregOp::INSERT_SLICE;
}
inline bool QuregOp::Builder::isInsertSlice() {
  return which() == QuregOp::INSERT_SLICE;
}
inline  ::capnp::Void QuregOp::Reader::getInsertSlice() const {
  KJ_IREQUIRE((which() == QuregOp::INSERT_SLICE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void QuregOp::Builder::getInsertSlice() {
  KJ_IREQUIRE((which() == QuregOp::INSERT_SLICE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void QuregOp::Builder::setInsertSlice( ::capnp::Void value) {
  _builder.setDataField<QuregOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, QuregOp::INSERT_SLICE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool QuregOp::Reader::isLength() const {
  return which() == QuregOp::LENGTH;
}
inline bool QuregOp::Builder::isLength() {
  return which() == QuregOp::LENGTH;
}
inline  ::capnp::Void QuregOp::Reader::getLength() const {
  KJ_IREQUIRE((which() == QuregOp::LENGTH),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void QuregOp::Builder::getLength() {
  KJ_IREQUIRE((which() == QuregOp::LENGTH),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void QuregOp::Builder::setLength( ::capnp::Void value) {
  _builder.setDataField<QuregOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, QuregOp::LENGTH);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool QuregOp::Reader::isSplit() const {
  return which() == QuregOp::SPLIT;
}
inline bool QuregOp::Builder::isSplit() {
  return which() == QuregOp::SPLIT;
}
inline  ::capnp::Void QuregOp::Reader::getSplit() const {
  KJ_IREQUIRE((which() == QuregOp::SPLIT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void QuregOp::Builder::getSplit() {
  KJ_IREQUIRE((which() == QuregOp::SPLIT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void QuregOp::Builder::setSplit( ::capnp::Void value) {
  _builder.setDataField<QuregOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, QuregOp::SPLIT);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool QuregOp::Reader::isJoin() const {
  return which() == QuregOp::JOIN;
}
inline bool QuregOp::Builder::isJoin() {
  return which() == QuregOp::JOIN;
}
inline  ::capnp::Void QuregOp::Reader::getJoin() const {
  KJ_IREQUIRE((which() == QuregOp::JOIN),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void QuregOp::Builder::getJoin() {
  KJ_IREQUIRE((which() == QuregOp::JOIN),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void QuregOp::Builder::setJoin( ::capnp::Void value) {
  _builder.setDataField<QuregOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, QuregOp::JOIN);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool QuregOp::Reader::isCreate() const {
  return which() == QuregOp::CREATE;
}
inline bool QuregOp::Builder::isCreate() {
  return which() == QuregOp::CREATE;
}
inline  ::capnp::Void QuregOp::Reader::getCreate() const {
  KJ_IREQUIRE((which() == QuregOp::CREATE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void QuregOp::Builder::getCreate() {
  KJ_IREQUIRE((which() == QuregOp::CREATE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void QuregOp::Builder::setCreate( ::capnp::Void value) {
  _builder.setDataField<QuregOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, QuregOp::CREATE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool QuregOp::Reader::isFree() const {
  return which() == QuregOp::FREE;
}
inline bool QuregOp::Builder::isFree() {
  return which() == QuregOp::FREE;
}
inline  ::capnp::Void QuregOp::Reader::getFree() const {
  KJ_IREQUIRE((which() == QuregOp::FREE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void QuregOp::Builder::getFree() {
  KJ_IREQUIRE((which() == QuregOp::FREE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void QuregOp::Builder::setFree( ::capnp::Void value) {
  _builder.setDataField<QuregOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, QuregOp::FREE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::jeff::IntOp::Which IntOp::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline  ::jeff::IntOp::Which IntOp::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool IntOp::Reader::isConst1() const {
  return which() == IntOp::CONST1;
}
inline bool IntOp::Builder::isConst1() {
  return which() == IntOp::CONST1;
}
inline bool IntOp::Reader::getConst1() const {
  KJ_IREQUIRE((which() == IntOp::CONST1),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool IntOp::Builder::getConst1() {
  KJ_IREQUIRE((which() == IntOp::CONST1),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setConst1(bool value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::CONST1);
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isConst8() const {
  return which() == IntOp::CONST8;
}
inline bool IntOp::Builder::isConst8() {
  return which() == IntOp::CONST8;
}
inline  ::uint8_t IntOp::Reader::getConst8() const {
  KJ_IREQUIRE((which() == IntOp::CONST8),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t IntOp::Builder::getConst8() {
  KJ_IREQUIRE((which() == IntOp::CONST8),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setConst8( ::uint8_t value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::CONST8);
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isConst16() const {
  return which() == IntOp::CONST16;
}
inline bool IntOp::Builder::isConst16() {
  return which() == IntOp::CONST16;
}
inline  ::uint16_t IntOp::Reader::getConst16() const {
  KJ_IREQUIRE((which() == IntOp::CONST16),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t IntOp::Builder::getConst16() {
  KJ_IREQUIRE((which() == IntOp::CONST16),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setConst16( ::uint16_t value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::CONST16);
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isConst32() const {
  return which() == IntOp::CONST32;
}
inline bool IntOp::Builder::isConst32() {
  return which() == IntOp::CONST32;
}
inline  ::uint32_t IntOp::Reader::getConst32() const {
  KJ_IREQUIRE((which() == IntOp::CONST32),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t IntOp::Builder::getConst32() {
  KJ_IREQUIRE((which() == IntOp::CONST32),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setConst32( ::uint32_t value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::CONST32);
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isConst64() const {
  return which() == IntOp::CONST64;
}
inline bool IntOp::Builder::isConst64() {
  return which() == IntOp::CONST64;
}
inline  ::uint64_t IntOp::Reader::getConst64() const {
  KJ_IREQUIRE((which() == IntOp::CONST64),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t IntOp::Builder::getConst64() {
  KJ_IREQUIRE((which() == IntOp::CONST64),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setConst64( ::uint64_t value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::CONST64);
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isAdd() const {
  return which() == IntOp::ADD;
}
inline bool IntOp::Builder::isAdd() {
  return which() == IntOp::ADD;
}
inline  ::capnp::Void IntOp::Reader::getAdd() const {
  KJ_IREQUIRE((which() == IntOp::ADD),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getAdd() {
  KJ_IREQUIRE((which() == IntOp::ADD),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setAdd( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::ADD);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isSub() const {
  return which() == IntOp::SUB;
}
inline bool IntOp::Builder::isSub() {
  return which() == IntOp::SUB;
}
inline  ::capnp::Void IntOp::Reader::getSub() const {
  KJ_IREQUIRE((which() == IntOp::SUB),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getSub() {
  KJ_IREQUIRE((which() == IntOp::SUB),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setSub( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::SUB);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isMul() const {
  return which() == IntOp::MUL;
}
inline bool IntOp::Builder::isMul() {
  return which() == IntOp::MUL;
}
inline  ::capnp::Void IntOp::Reader::getMul() const {
  KJ_IREQUIRE((which() == IntOp::MUL),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getMul() {
  KJ_IREQUIRE((which() == IntOp::MUL),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setMul( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::MUL);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isDivS() const {
  return which() == IntOp::DIV_S;
}
inline bool IntOp::Builder::isDivS() {
  return which() == IntOp::DIV_S;
}
inline  ::capnp::Void IntOp::Reader::getDivS() const {
  KJ_IREQUIRE((which() == IntOp::DIV_S),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getDivS() {
  KJ_IREQUIRE((which() == IntOp::DIV_S),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setDivS( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::DIV_S);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isDivU() const {
  return which() == IntOp::DIV_U;
}
inline bool IntOp::Builder::isDivU() {
  return which() == IntOp::DIV_U;
}
inline  ::capnp::Void IntOp::Reader::getDivU() const {
  KJ_IREQUIRE((which() == IntOp::DIV_U),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getDivU() {
  KJ_IREQUIRE((which() == IntOp::DIV_U),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setDivU( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::DIV_U);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isPow() const {
  return which() == IntOp::POW;
}
inline bool IntOp::Builder::isPow() {
  return which() == IntOp::POW;
}
inline  ::capnp::Void IntOp::Reader::getPow() const {
  KJ_IREQUIRE((which() == IntOp::POW),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getPow() {
  KJ_IREQUIRE((which() == IntOp::POW),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setPow( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::POW);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isAnd() const {
  return which() == IntOp::AND;
}
inline bool IntOp::Builder::isAnd() {
  return which() == IntOp::AND;
}
inline  ::capnp::Void IntOp::Reader::getAnd() const {
  KJ_IREQUIRE((which() == IntOp::AND),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getAnd() {
  KJ_IREQUIRE((which() == IntOp::AND),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setAnd( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::AND);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isOr() const {
  return which() == IntOp::OR;
}
inline bool IntOp::Builder::isOr() {
  return which() == IntOp::OR;
}
inline  ::capnp::Void IntOp::Reader::getOr() const {
  KJ_IREQUIRE((which() == IntOp::OR),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getOr() {
  KJ_IREQUIRE((which() == IntOp::OR),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setOr( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::OR);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isXor() const {
  return which() == IntOp::XOR;
}
inline bool IntOp::Builder::isXor() {
  return which() == IntOp::XOR;
}
inline  ::capnp::Void IntOp::Reader::getXor() const {
  KJ_IREQUIRE((which() == IntOp::XOR),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getXor() {
  KJ_IREQUIRE((which() == IntOp::XOR),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setXor( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::XOR);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isNot() const {
  return which() == IntOp::NOT;
}
inline bool IntOp::Builder::isNot() {
  return which() == IntOp::NOT;
}
inline  ::capnp::Void IntOp::Reader::getNot() const {
  KJ_IREQUIRE((which() == IntOp::NOT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getNot() {
  KJ_IREQUIRE((which() == IntOp::NOT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setNot( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::NOT);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isMinS() const {
  return which() == IntOp::MIN_S;
}
inline bool IntOp::Builder::isMinS() {
  return which() == IntOp::MIN_S;
}
inline  ::capnp::Void IntOp::Reader::getMinS() const {
  KJ_IREQUIRE((which() == IntOp::MIN_S),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getMinS() {
  KJ_IREQUIRE((which() == IntOp::MIN_S),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setMinS( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::MIN_S);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isMinU() const {
  return which() == IntOp::MIN_U;
}
inline bool IntOp::Builder::isMinU() {
  return which() == IntOp::MIN_U;
}
inline  ::capnp::Void IntOp::Reader::getMinU() const {
  KJ_IREQUIRE((which() == IntOp::MIN_U),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getMinU() {
  KJ_IREQUIRE((which() == IntOp::MIN_U),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setMinU( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::MIN_U);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isMaxS() const {
  return which() == IntOp::MAX_S;
}
inline bool IntOp::Builder::isMaxS() {
  return which() == IntOp::MAX_S;
}
inline  ::capnp::Void IntOp::Reader::getMaxS() const {
  KJ_IREQUIRE((which() == IntOp::MAX_S),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getMaxS() {
  KJ_IREQUIRE((which() == IntOp::MAX_S),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setMaxS( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::MAX_S);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isMaxU() const {
  return which() == IntOp::MAX_U;
}
inline bool IntOp::Builder::isMaxU() {
  return which() == IntOp::MAX_U;
}
inline  ::capnp::Void IntOp::Reader::getMaxU() const {
  KJ_IREQUIRE((which() == IntOp::MAX_U),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getMaxU() {
  KJ_IREQUIRE((which() == IntOp::MAX_U),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setMaxU( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::MAX_U);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isEq() const {
  return which() == IntOp::EQ;
}
inline bool IntOp::Builder::isEq() {
  return which() == IntOp::EQ;
}
inline  ::capnp::Void IntOp::Reader::getEq() const {
  KJ_IREQUIRE((which() == IntOp::EQ),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getEq() {
  KJ_IREQUIRE((which() == IntOp::EQ),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setEq( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::EQ);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isLtS() const {
  return which() == IntOp::LT_S;
}
inline bool IntOp::Builder::isLtS() {
  return which() == IntOp::LT_S;
}
inline  ::capnp::Void IntOp::Reader::getLtS() const {
  KJ_IREQUIRE((which() == IntOp::LT_S),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getLtS() {
  KJ_IREQUIRE((which() == IntOp::LT_S),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setLtS( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::LT_S);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isLteS() const {
  return which() == IntOp::LTE_S;
}
inline bool IntOp::Builder::isLteS() {
  return which() == IntOp::LTE_S;
}
inline  ::capnp::Void IntOp::Reader::getLteS() const {
  KJ_IREQUIRE((which() == IntOp::LTE_S),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getLteS() {
  KJ_IREQUIRE((which() == IntOp::LTE_S),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setLteS( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::LTE_S);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isLtU() const {
  return which() == IntOp::LT_U;
}
inline bool IntOp::Builder::isLtU() {
  return which() == IntOp::LT_U;
}
inline  ::capnp::Void IntOp::Reader::getLtU() const {
  KJ_IREQUIRE((which() == IntOp::LT_U),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getLtU() {
  KJ_IREQUIRE((which() == IntOp::LT_U),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setLtU( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::LT_U);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isLteU() const {
  return which() == IntOp::LTE_U;
}
inline bool IntOp::Builder::isLteU() {
  return which() == IntOp::LTE_U;
}
inline  ::capnp::Void IntOp::Reader::getLteU() const {
  KJ_IREQUIRE((which() == IntOp::LTE_U),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getLteU() {
  KJ_IREQUIRE((which() == IntOp::LTE_U),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setLteU( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::LTE_U);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isAbs() const {
  return which() == IntOp::ABS;
}
inline bool IntOp::Builder::isAbs() {
  return which() == IntOp::ABS;
}
inline  ::capnp::Void IntOp::Reader::getAbs() const {
  KJ_IREQUIRE((which() == IntOp::ABS),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getAbs() {
  KJ_IREQUIRE((which() == IntOp::ABS),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setAbs( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::ABS);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isRemS() const {
  return which() == IntOp::REM_S;
}
inline bool IntOp::Builder::isRemS() {
  return which() == IntOp::REM_S;
}
inline  ::capnp::Void IntOp::Reader::getRemS() const {
  KJ_IREQUIRE((which() == IntOp::REM_S),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getRemS() {
  KJ_IREQUIRE((which() == IntOp::REM_S),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setRemS( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::REM_S);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isRemU() const {
  return which() == IntOp::REM_U;
}
inline bool IntOp::Builder::isRemU() {
  return which() == IntOp::REM_U;
}
inline  ::capnp::Void IntOp::Reader::getRemU() const {
  KJ_IREQUIRE((which() == IntOp::REM_U),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getRemU() {
  KJ_IREQUIRE((which() == IntOp::REM_U),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setRemU( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::REM_U);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isShl() const {
  return which() == IntOp::SHL;
}
inline bool IntOp::Builder::isShl() {
  return which() == IntOp::SHL;
}
inline  ::capnp::Void IntOp::Reader::getShl() const {
  KJ_IREQUIRE((which() == IntOp::SHL),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getShl() {
  KJ_IREQUIRE((which() == IntOp::SHL),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setShl( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::SHL);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntOp::Reader::isShr() const {
  return which() == IntOp::SHR;
}
inline bool IntOp::Builder::isShr() {
  return which() == IntOp::SHR;
}
inline  ::capnp::Void IntOp::Reader::getShr() const {
  KJ_IREQUIRE((which() == IntOp::SHR),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntOp::Builder::getShr() {
  KJ_IREQUIRE((which() == IntOp::SHR),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntOp::Builder::setShr( ::capnp::Void value) {
  _builder.setDataField<IntOp::Which>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, IntOp::SHR);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::jeff::IntArrayOp::Which IntArrayOp::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::jeff::IntArrayOp::Which IntArrayOp::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool IntArrayOp::Reader::isConst1() const {
  return which() == IntArrayOp::CONST1;
}
inline bool IntArrayOp::Builder::isConst1() {
  return which() == IntArrayOp::CONST1;
}
inline bool IntArrayOp::Reader::hasConst1() const {
  if (which() != IntArrayOp::CONST1) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool IntArrayOp::Builder::hasConst1() {
  if (which() != IntArrayOp::CONST1) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Reader IntArrayOp::Reader::getConst1() const {
  KJ_IREQUIRE((which() == IntArrayOp::CONST1),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Builder IntArrayOp::Builder::getConst1() {
  KJ_IREQUIRE((which() == IntArrayOp::CONST1),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void IntArrayOp::Builder::setConst1( ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::CONST1);
  ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void IntArrayOp::Builder::setConst1(::kj::ArrayPtr<const bool> value) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::CONST1);
  ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>::Builder IntArrayOp::Builder::initConst1(unsigned int size) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::CONST1);
  return ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void IntArrayOp::Builder::adoptConst1(
    ::capnp::Orphan< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::CONST1);
  ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>> IntArrayOp::Builder::disownConst1() {
  KJ_IREQUIRE((which() == IntArrayOp::CONST1),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List<bool,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool IntArrayOp::Reader::isConst8() const {
  return which() == IntArrayOp::CONST8;
}
inline bool IntArrayOp::Builder::isConst8() {
  return which() == IntArrayOp::CONST8;
}
inline bool IntArrayOp::Reader::hasConst8() const {
  if (which() != IntArrayOp::CONST8) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool IntArrayOp::Builder::hasConst8() {
  if (which() != IntArrayOp::CONST8) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader IntArrayOp::Reader::getConst8() const {
  KJ_IREQUIRE((which() == IntArrayOp::CONST8),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder IntArrayOp::Builder::getConst8() {
  KJ_IREQUIRE((which() == IntArrayOp::CONST8),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void IntArrayOp::Builder::setConst8( ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::CONST8);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void IntArrayOp::Builder::setConst8(::kj::ArrayPtr<const  ::uint8_t> value) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::CONST8);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder IntArrayOp::Builder::initConst8(unsigned int size) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::CONST8);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void IntArrayOp::Builder::adoptConst8(
    ::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::CONST8);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>> IntArrayOp::Builder::disownConst8() {
  KJ_IREQUIRE((which() == IntArrayOp::CONST8),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool IntArrayOp::Reader::isConst16() const {
  return which() == IntArrayOp::CONST16;
}
inline bool IntArrayOp::Builder::isConst16() {
  return which() == IntArrayOp::CONST16;
}
inline bool IntArrayOp::Reader::hasConst16() const {
  if (which() != IntArrayOp::CONST16) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool IntArrayOp::Builder::hasConst16() {
  if (which() != IntArrayOp::CONST16) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>::Reader IntArrayOp::Reader::getConst16() const {
  KJ_IREQUIRE((which() == IntArrayOp::CONST16),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>::Builder IntArrayOp::Builder::getConst16() {
  KJ_IREQUIRE((which() == IntArrayOp::CONST16),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void IntArrayOp::Builder::setConst16( ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::CONST16);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void IntArrayOp::Builder::setConst16(::kj::ArrayPtr<const  ::uint16_t> value) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::CONST16);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>::Builder IntArrayOp::Builder::initConst16(unsigned int size) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::CONST16);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void IntArrayOp::Builder::adoptConst16(
    ::capnp::Orphan< ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::CONST16);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>> IntArrayOp::Builder::disownConst16() {
  KJ_IREQUIRE((which() == IntArrayOp::CONST16),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint16_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool IntArrayOp::Reader::isConst32() const {
  return which() == IntArrayOp::CONST32;
}
inline bool IntArrayOp::Builder::isConst32() {
  return which() == IntArrayOp::CONST32;
}
inline bool IntArrayOp::Reader::hasConst32() const {
  if (which() != IntArrayOp::CONST32) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool IntArrayOp::Builder::hasConst32() {
  if (which() != IntArrayOp::CONST32) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader IntArrayOp::Reader::getConst32() const {
  KJ_IREQUIRE((which() == IntArrayOp::CONST32),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder IntArrayOp::Builder::getConst32() {
  KJ_IREQUIRE((which() == IntArrayOp::CONST32),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void IntArrayOp::Builder::setConst32( ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::CONST32);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void IntArrayOp::Builder::setConst32(::kj::ArrayPtr<const  ::uint32_t> value) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::CONST32);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>::Builder IntArrayOp::Builder::initConst32(unsigned int size) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::CONST32);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void IntArrayOp::Builder::adoptConst32(
    ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::CONST32);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>> IntArrayOp::Builder::disownConst32() {
  KJ_IREQUIRE((which() == IntArrayOp::CONST32),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint32_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool IntArrayOp::Reader::isConst64() const {
  return which() == IntArrayOp::CONST64;
}
inline bool IntArrayOp::Builder::isConst64() {
  return which() == IntArrayOp::CONST64;
}
inline bool IntArrayOp::Reader::hasConst64() const {
  if (which() != IntArrayOp::CONST64) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool IntArrayOp::Builder::hasConst64() {
  if (which() != IntArrayOp::CONST64) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader IntArrayOp::Reader::getConst64() const {
  KJ_IREQUIRE((which() == IntArrayOp::CONST64),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder IntArrayOp::Builder::getConst64() {
  KJ_IREQUIRE((which() == IntArrayOp::CONST64),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void IntArrayOp::Builder::setConst64( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::CONST64);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void IntArrayOp::Builder::setConst64(::kj::ArrayPtr<const  ::uint64_t> value) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::CONST64);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder IntArrayOp::Builder::initConst64(unsigned int size) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::CONST64);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void IntArrayOp::Builder::adoptConst64(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::CONST64);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> IntArrayOp::Builder::disownConst64() {
  KJ_IREQUIRE((which() == IntArrayOp::CONST64),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool IntArrayOp::Reader::isZero() const {
  return which() == IntArrayOp::ZERO;
}
inline bool IntArrayOp::Builder::isZero() {
  return which() == IntArrayOp::ZERO;
}
inline  ::uint8_t IntArrayOp::Reader::getZero() const {
  KJ_IREQUIRE((which() == IntArrayOp::ZERO),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t IntArrayOp::Builder::getZero() {
  KJ_IREQUIRE((which() == IntArrayOp::ZERO),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void IntArrayOp::Builder::setZero( ::uint8_t value) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::ZERO);
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool IntArrayOp::Reader::isGetIndex() const {
  return which() == IntArrayOp::GET_INDEX;
}
inline bool IntArrayOp::Builder::isGetIndex() {
  return which() == IntArrayOp::GET_INDEX;
}
inline  ::capnp::Void IntArrayOp::Reader::getGetIndex() const {
  KJ_IREQUIRE((which() == IntArrayOp::GET_INDEX),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntArrayOp::Builder::getGetIndex() {
  KJ_IREQUIRE((which() == IntArrayOp::GET_INDEX),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntArrayOp::Builder::setGetIndex( ::capnp::Void value) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::GET_INDEX);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntArrayOp::Reader::isSetIndex() const {
  return which() == IntArrayOp::SET_INDEX;
}
inline bool IntArrayOp::Builder::isSetIndex() {
  return which() == IntArrayOp::SET_INDEX;
}
inline  ::capnp::Void IntArrayOp::Reader::getSetIndex() const {
  KJ_IREQUIRE((which() == IntArrayOp::SET_INDEX),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntArrayOp::Builder::getSetIndex() {
  KJ_IREQUIRE((which() == IntArrayOp::SET_INDEX),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntArrayOp::Builder::setSetIndex( ::capnp::Void value) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::SET_INDEX);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntArrayOp::Reader::isLength() const {
  return which() == IntArrayOp::LENGTH;
}
inline bool IntArrayOp::Builder::isLength() {
  return which() == IntArrayOp::LENGTH;
}
inline  ::capnp::Void IntArrayOp::Reader::getLength() const {
  KJ_IREQUIRE((which() == IntArrayOp::LENGTH),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntArrayOp::Builder::getLength() {
  KJ_IREQUIRE((which() == IntArrayOp::LENGTH),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntArrayOp::Builder::setLength( ::capnp::Void value) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::LENGTH);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool IntArrayOp::Reader::isCreate() const {
  return which() == IntArrayOp::CREATE;
}
inline bool IntArrayOp::Builder::isCreate() {
  return which() == IntArrayOp::CREATE;
}
inline  ::capnp::Void IntArrayOp::Reader::getCreate() const {
  KJ_IREQUIRE((which() == IntArrayOp::CREATE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void IntArrayOp::Builder::getCreate() {
  KJ_IREQUIRE((which() == IntArrayOp::CREATE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IntArrayOp::Builder::setCreate( ::capnp::Void value) {
  _builder.setDataField<IntArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, IntArrayOp::CREATE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::jeff::FloatOp::Which FloatOp::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline  ::jeff::FloatOp::Which FloatOp::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline bool FloatOp::Reader::isConst32() const {
  return which() == FloatOp::CONST32;
}
inline bool FloatOp::Builder::isConst32() {
  return which() == FloatOp::CONST32;
}
inline float FloatOp::Reader::getConst32() const {
  KJ_IREQUIRE((which() == FloatOp::CONST32),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float FloatOp::Builder::getConst32() {
  KJ_IREQUIRE((which() == FloatOp::CONST32),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setConst32(float value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::CONST32);
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isConst64() const {
  return which() == FloatOp::CONST64;
}
inline bool FloatOp::Builder::isConst64() {
  return which() == FloatOp::CONST64;
}
inline double FloatOp::Reader::getConst64() const {
  KJ_IREQUIRE((which() == FloatOp::CONST64),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double FloatOp::Builder::getConst64() {
  KJ_IREQUIRE((which() == FloatOp::CONST64),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setConst64(double value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::CONST64);
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isAdd() const {
  return which() == FloatOp::ADD;
}
inline bool FloatOp::Builder::isAdd() {
  return which() == FloatOp::ADD;
}
inline  ::capnp::Void FloatOp::Reader::getAdd() const {
  KJ_IREQUIRE((which() == FloatOp::ADD),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getAdd() {
  KJ_IREQUIRE((which() == FloatOp::ADD),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setAdd( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::ADD);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isSub() const {
  return which() == FloatOp::SUB;
}
inline bool FloatOp::Builder::isSub() {
  return which() == FloatOp::SUB;
}
inline  ::capnp::Void FloatOp::Reader::getSub() const {
  KJ_IREQUIRE((which() == FloatOp::SUB),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getSub() {
  KJ_IREQUIRE((which() == FloatOp::SUB),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setSub( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::SUB);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isMul() const {
  return which() == FloatOp::MUL;
}
inline bool FloatOp::Builder::isMul() {
  return which() == FloatOp::MUL;
}
inline  ::capnp::Void FloatOp::Reader::getMul() const {
  KJ_IREQUIRE((which() == FloatOp::MUL),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getMul() {
  KJ_IREQUIRE((which() == FloatOp::MUL),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setMul( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::MUL);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isPow() const {
  return which() == FloatOp::POW;
}
inline bool FloatOp::Builder::isPow() {
  return which() == FloatOp::POW;
}
inline  ::capnp::Void FloatOp::Reader::getPow() const {
  KJ_IREQUIRE((which() == FloatOp::POW),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getPow() {
  KJ_IREQUIRE((which() == FloatOp::POW),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setPow( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::POW);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isEq() const {
  return which() == FloatOp::EQ;
}
inline bool FloatOp::Builder::isEq() {
  return which() == FloatOp::EQ;
}
inline  ::capnp::Void FloatOp::Reader::getEq() const {
  KJ_IREQUIRE((which() == FloatOp::EQ),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getEq() {
  KJ_IREQUIRE((which() == FloatOp::EQ),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setEq( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::EQ);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isLt() const {
  return which() == FloatOp::LT;
}
inline bool FloatOp::Builder::isLt() {
  return which() == FloatOp::LT;
}
inline  ::capnp::Void FloatOp::Reader::getLt() const {
  KJ_IREQUIRE((which() == FloatOp::LT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getLt() {
  KJ_IREQUIRE((which() == FloatOp::LT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setLt( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::LT);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isLte() const {
  return which() == FloatOp::LTE;
}
inline bool FloatOp::Builder::isLte() {
  return which() == FloatOp::LTE;
}
inline  ::capnp::Void FloatOp::Reader::getLte() const {
  KJ_IREQUIRE((which() == FloatOp::LTE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getLte() {
  KJ_IREQUIRE((which() == FloatOp::LTE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setLte( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::LTE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isSqrt() const {
  return which() == FloatOp::SQRT;
}
inline bool FloatOp::Builder::isSqrt() {
  return which() == FloatOp::SQRT;
}
inline  ::capnp::Void FloatOp::Reader::getSqrt() const {
  KJ_IREQUIRE((which() == FloatOp::SQRT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getSqrt() {
  KJ_IREQUIRE((which() == FloatOp::SQRT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setSqrt( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::SQRT);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isAbs() const {
  return which() == FloatOp::ABS;
}
inline bool FloatOp::Builder::isAbs() {
  return which() == FloatOp::ABS;
}
inline  ::capnp::Void FloatOp::Reader::getAbs() const {
  KJ_IREQUIRE((which() == FloatOp::ABS),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getAbs() {
  KJ_IREQUIRE((which() == FloatOp::ABS),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setAbs( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::ABS);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isCeil() const {
  return which() == FloatOp::CEIL;
}
inline bool FloatOp::Builder::isCeil() {
  return which() == FloatOp::CEIL;
}
inline  ::capnp::Void FloatOp::Reader::getCeil() const {
  KJ_IREQUIRE((which() == FloatOp::CEIL),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getCeil() {
  KJ_IREQUIRE((which() == FloatOp::CEIL),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setCeil( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::CEIL);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isFloor() const {
  return which() == FloatOp::FLOOR;
}
inline bool FloatOp::Builder::isFloor() {
  return which() == FloatOp::FLOOR;
}
inline  ::capnp::Void FloatOp::Reader::getFloor() const {
  KJ_IREQUIRE((which() == FloatOp::FLOOR),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getFloor() {
  KJ_IREQUIRE((which() == FloatOp::FLOOR),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setFloor( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::FLOOR);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isIsNan() const {
  return which() == FloatOp::IS_NAN;
}
inline bool FloatOp::Builder::isIsNan() {
  return which() == FloatOp::IS_NAN;
}
inline  ::capnp::Void FloatOp::Reader::getIsNan() const {
  KJ_IREQUIRE((which() == FloatOp::IS_NAN),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getIsNan() {
  KJ_IREQUIRE((which() == FloatOp::IS_NAN),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setIsNan( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::IS_NAN);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isIsInf() const {
  return which() == FloatOp::IS_INF;
}
inline bool FloatOp::Builder::isIsInf() {
  return which() == FloatOp::IS_INF;
}
inline  ::capnp::Void FloatOp::Reader::getIsInf() const {
  KJ_IREQUIRE((which() == FloatOp::IS_INF),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getIsInf() {
  KJ_IREQUIRE((which() == FloatOp::IS_INF),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setIsInf( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::IS_INF);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isExp() const {
  return which() == FloatOp::EXP;
}
inline bool FloatOp::Builder::isExp() {
  return which() == FloatOp::EXP;
}
inline  ::capnp::Void FloatOp::Reader::getExp() const {
  KJ_IREQUIRE((which() == FloatOp::EXP),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getExp() {
  KJ_IREQUIRE((which() == FloatOp::EXP),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setExp( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::EXP);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isLog() const {
  return which() == FloatOp::LOG;
}
inline bool FloatOp::Builder::isLog() {
  return which() == FloatOp::LOG;
}
inline  ::capnp::Void FloatOp::Reader::getLog() const {
  KJ_IREQUIRE((which() == FloatOp::LOG),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getLog() {
  KJ_IREQUIRE((which() == FloatOp::LOG),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setLog( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::LOG);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isSin() const {
  return which() == FloatOp::SIN;
}
inline bool FloatOp::Builder::isSin() {
  return which() == FloatOp::SIN;
}
inline  ::capnp::Void FloatOp::Reader::getSin() const {
  KJ_IREQUIRE((which() == FloatOp::SIN),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getSin() {
  KJ_IREQUIRE((which() == FloatOp::SIN),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setSin( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::SIN);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isCos() const {
  return which() == FloatOp::COS;
}
inline bool FloatOp::Builder::isCos() {
  return which() == FloatOp::COS;
}
inline  ::capnp::Void FloatOp::Reader::getCos() const {
  KJ_IREQUIRE((which() == FloatOp::COS),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getCos() {
  KJ_IREQUIRE((which() == FloatOp::COS),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setCos( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::COS);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isTan() const {
  return which() == FloatOp::TAN;
}
inline bool FloatOp::Builder::isTan() {
  return which() == FloatOp::TAN;
}
inline  ::capnp::Void FloatOp::Reader::getTan() const {
  KJ_IREQUIRE((which() == FloatOp::TAN),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getTan() {
  KJ_IREQUIRE((which() == FloatOp::TAN),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setTan( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::TAN);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isAsin() const {
  return which() == FloatOp::ASIN;
}
inline bool FloatOp::Builder::isAsin() {
  return which() == FloatOp::ASIN;
}
inline  ::capnp::Void FloatOp::Reader::getAsin() const {
  KJ_IREQUIRE((which() == FloatOp::ASIN),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getAsin() {
  KJ_IREQUIRE((which() == FloatOp::ASIN),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setAsin( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::ASIN);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isAcos() const {
  return which() == FloatOp::ACOS;
}
inline bool FloatOp::Builder::isAcos() {
  return which() == FloatOp::ACOS;
}
inline  ::capnp::Void FloatOp::Reader::getAcos() const {
  KJ_IREQUIRE((which() == FloatOp::ACOS),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getAcos() {
  KJ_IREQUIRE((which() == FloatOp::ACOS),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setAcos( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::ACOS);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isAtan() const {
  return which() == FloatOp::ATAN;
}
inline bool FloatOp::Builder::isAtan() {
  return which() == FloatOp::ATAN;
}
inline  ::capnp::Void FloatOp::Reader::getAtan() const {
  KJ_IREQUIRE((which() == FloatOp::ATAN),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getAtan() {
  KJ_IREQUIRE((which() == FloatOp::ATAN),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setAtan( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::ATAN);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isAtan2() const {
  return which() == FloatOp::ATAN2;
}
inline bool FloatOp::Builder::isAtan2() {
  return which() == FloatOp::ATAN2;
}
inline  ::capnp::Void FloatOp::Reader::getAtan2() const {
  KJ_IREQUIRE((which() == FloatOp::ATAN2),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getAtan2() {
  KJ_IREQUIRE((which() == FloatOp::ATAN2),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setAtan2( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::ATAN2);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isSinh() const {
  return which() == FloatOp::SINH;
}
inline bool FloatOp::Builder::isSinh() {
  return which() == FloatOp::SINH;
}
inline  ::capnp::Void FloatOp::Reader::getSinh() const {
  KJ_IREQUIRE((which() == FloatOp::SINH),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getSinh() {
  KJ_IREQUIRE((which() == FloatOp::SINH),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setSinh( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::SINH);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isCosh() const {
  return which() == FloatOp::COSH;
}
inline bool FloatOp::Builder::isCosh() {
  return which() == FloatOp::COSH;
}
inline  ::capnp::Void FloatOp::Reader::getCosh() const {
  KJ_IREQUIRE((which() == FloatOp::COSH),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getCosh() {
  KJ_IREQUIRE((which() == FloatOp::COSH),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setCosh( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::COSH);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isTanh() const {
  return which() == FloatOp::TANH;
}
inline bool FloatOp::Builder::isTanh() {
  return which() == FloatOp::TANH;
}
inline  ::capnp::Void FloatOp::Reader::getTanh() const {
  KJ_IREQUIRE((which() == FloatOp::TANH),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getTanh() {
  KJ_IREQUIRE((which() == FloatOp::TANH),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setTanh( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::TANH);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isAsinh() const {
  return which() == FloatOp::ASINH;
}
inline bool FloatOp::Builder::isAsinh() {
  return which() == FloatOp::ASINH;
}
inline  ::capnp::Void FloatOp::Reader::getAsinh() const {
  KJ_IREQUIRE((which() == FloatOp::ASINH),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getAsinh() {
  KJ_IREQUIRE((which() == FloatOp::ASINH),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setAsinh( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::ASINH);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isAcosh() const {
  return which() == FloatOp::ACOSH;
}
inline bool FloatOp::Builder::isAcosh() {
  return which() == FloatOp::ACOSH;
}
inline  ::capnp::Void FloatOp::Reader::getAcosh() const {
  KJ_IREQUIRE((which() == FloatOp::ACOSH),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getAcosh() {
  KJ_IREQUIRE((which() == FloatOp::ACOSH),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setAcosh( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::ACOSH);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isAtanh() const {
  return which() == FloatOp::ATANH;
}
inline bool FloatOp::Builder::isAtanh() {
  return which() == FloatOp::ATANH;
}
inline  ::capnp::Void FloatOp::Reader::getAtanh() const {
  KJ_IREQUIRE((which() == FloatOp::ATANH),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getAtanh() {
  KJ_IREQUIRE((which() == FloatOp::ATANH),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setAtanh( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::ATANH);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isMax() const {
  return which() == FloatOp::MAX;
}
inline bool FloatOp::Builder::isMax() {
  return which() == FloatOp::MAX;
}
inline  ::capnp::Void FloatOp::Reader::getMax() const {
  KJ_IREQUIRE((which() == FloatOp::MAX),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getMax() {
  KJ_IREQUIRE((which() == FloatOp::MAX),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setMax( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::MAX);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatOp::Reader::isMin() const {
  return which() == FloatOp::MIN;
}
inline bool FloatOp::Builder::isMin() {
  return which() == FloatOp::MIN;
}
inline  ::capnp::Void FloatOp::Reader::getMin() const {
  KJ_IREQUIRE((which() == FloatOp::MIN),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatOp::Builder::getMin() {
  KJ_IREQUIRE((which() == FloatOp::MIN),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatOp::Builder::setMin( ::capnp::Void value) {
  _builder.setDataField<FloatOp::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, FloatOp::MIN);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::jeff::FloatArrayOp::Which FloatArrayOp::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::jeff::FloatArrayOp::Which FloatArrayOp::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool FloatArrayOp::Reader::isConst32() const {
  return which() == FloatArrayOp::CONST32;
}
inline bool FloatArrayOp::Builder::isConst32() {
  return which() == FloatArrayOp::CONST32;
}
inline bool FloatArrayOp::Reader::hasConst32() const {
  if (which() != FloatArrayOp::CONST32) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FloatArrayOp::Builder::hasConst32() {
  if (which() != FloatArrayOp::CONST32) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader FloatArrayOp::Reader::getConst32() const {
  KJ_IREQUIRE((which() == FloatArrayOp::CONST32),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder FloatArrayOp::Builder::getConst32() {
  KJ_IREQUIRE((which() == FloatArrayOp::CONST32),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FloatArrayOp::Builder::setConst32( ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<FloatArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, FloatArrayOp::CONST32);
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void FloatArrayOp::Builder::setConst32(::kj::ArrayPtr<const float> value) {
  _builder.setDataField<FloatArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, FloatArrayOp::CONST32);
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>::Builder FloatArrayOp::Builder::initConst32(unsigned int size) {
  _builder.setDataField<FloatArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, FloatArrayOp::CONST32);
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void FloatArrayOp::Builder::adoptConst32(
    ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<FloatArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, FloatArrayOp::CONST32);
  ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>> FloatArrayOp::Builder::disownConst32() {
  KJ_IREQUIRE((which() == FloatArrayOp::CONST32),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List<float,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool FloatArrayOp::Reader::isConst64() const {
  return which() == FloatArrayOp::CONST64;
}
inline bool FloatArrayOp::Builder::isConst64() {
  return which() == FloatArrayOp::CONST64;
}
inline bool FloatArrayOp::Reader::hasConst64() const {
  if (which() != FloatArrayOp::CONST64) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FloatArrayOp::Builder::hasConst64() {
  if (which() != FloatArrayOp::CONST64) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader FloatArrayOp::Reader::getConst64() const {
  KJ_IREQUIRE((which() == FloatArrayOp::CONST64),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder FloatArrayOp::Builder::getConst64() {
  KJ_IREQUIRE((which() == FloatArrayOp::CONST64),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FloatArrayOp::Builder::setConst64( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<FloatArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, FloatArrayOp::CONST64);
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void FloatArrayOp::Builder::setConst64(::kj::ArrayPtr<const double> value) {
  _builder.setDataField<FloatArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, FloatArrayOp::CONST64);
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder FloatArrayOp::Builder::initConst64(unsigned int size) {
  _builder.setDataField<FloatArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, FloatArrayOp::CONST64);
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void FloatArrayOp::Builder::adoptConst64(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<FloatArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, FloatArrayOp::CONST64);
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> FloatArrayOp::Builder::disownConst64() {
  KJ_IREQUIRE((which() == FloatArrayOp::CONST64),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool FloatArrayOp::Reader::isZero() const {
  return which() == FloatArrayOp::ZERO;
}
inline bool FloatArrayOp::Builder::isZero() {
  return which() == FloatArrayOp::ZERO;
}
inline  ::jeff::FloatPrecision FloatArrayOp::Reader::getZero() const {
  KJ_IREQUIRE((which() == FloatArrayOp::ZERO),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::jeff::FloatPrecision>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::jeff::FloatPrecision FloatArrayOp::Builder::getZero() {
  KJ_IREQUIRE((which() == FloatArrayOp::ZERO),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::jeff::FloatPrecision>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void FloatArrayOp::Builder::setZero( ::jeff::FloatPrecision value) {
  _builder.setDataField<FloatArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, FloatArrayOp::ZERO);
  _builder.setDataField< ::jeff::FloatPrecision>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool FloatArrayOp::Reader::isGetIndex() const {
  return which() == FloatArrayOp::GET_INDEX;
}
inline bool FloatArrayOp::Builder::isGetIndex() {
  return which() == FloatArrayOp::GET_INDEX;
}
inline  ::capnp::Void FloatArrayOp::Reader::getGetIndex() const {
  KJ_IREQUIRE((which() == FloatArrayOp::GET_INDEX),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatArrayOp::Builder::getGetIndex() {
  KJ_IREQUIRE((which() == FloatArrayOp::GET_INDEX),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatArrayOp::Builder::setGetIndex( ::capnp::Void value) {
  _builder.setDataField<FloatArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, FloatArrayOp::GET_INDEX);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatArrayOp::Reader::isSetIndex() const {
  return which() == FloatArrayOp::SET_INDEX;
}
inline bool FloatArrayOp::Builder::isSetIndex() {
  return which() == FloatArrayOp::SET_INDEX;
}
inline  ::capnp::Void FloatArrayOp::Reader::getSetIndex() const {
  KJ_IREQUIRE((which() == FloatArrayOp::SET_INDEX),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatArrayOp::Builder::getSetIndex() {
  KJ_IREQUIRE((which() == FloatArrayOp::SET_INDEX),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatArrayOp::Builder::setSetIndex( ::capnp::Void value) {
  _builder.setDataField<FloatArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, FloatArrayOp::SET_INDEX);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatArrayOp::Reader::isLength() const {
  return which() == FloatArrayOp::LENGTH;
}
inline bool FloatArrayOp::Builder::isLength() {
  return which() == FloatArrayOp::LENGTH;
}
inline  ::capnp::Void FloatArrayOp::Reader::getLength() const {
  KJ_IREQUIRE((which() == FloatArrayOp::LENGTH),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatArrayOp::Builder::getLength() {
  KJ_IREQUIRE((which() == FloatArrayOp::LENGTH),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatArrayOp::Builder::setLength( ::capnp::Void value) {
  _builder.setDataField<FloatArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, FloatArrayOp::LENGTH);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FloatArrayOp::Reader::isCreate() const {
  return which() == FloatArrayOp::CREATE;
}
inline bool FloatArrayOp::Builder::isCreate() {
  return which() == FloatArrayOp::CREATE;
}
inline  ::capnp::Void FloatArrayOp::Reader::getCreate() const {
  KJ_IREQUIRE((which() == FloatArrayOp::CREATE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void FloatArrayOp::Builder::getCreate() {
  KJ_IREQUIRE((which() == FloatArrayOp::CREATE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FloatArrayOp::Builder::setCreate( ::capnp::Void value) {
  _builder.setDataField<FloatArrayOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, FloatArrayOp::CREATE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::jeff::ScfOp::Which ScfOp::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::jeff::ScfOp::Which ScfOp::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool ScfOp::Reader::isSwitch() const {
  return which() == ScfOp::SWITCH;
}
inline bool ScfOp::Builder::isSwitch() {
  return which() == ScfOp::SWITCH;
}
inline typename ScfOp::Switch::Reader ScfOp::Reader::getSwitch() const {
  KJ_IREQUIRE((which() == ScfOp::SWITCH),
              "Must check which() before get()ing a union member.");
  return typename ScfOp::Switch::Reader(_reader);
}
inline typename ScfOp::Switch::Builder ScfOp::Builder::getSwitch() {
  KJ_IREQUIRE((which() == ScfOp::SWITCH),
              "Must check which() before get()ing a union member.");
  return typename ScfOp::Switch::Builder(_builder);
}
inline typename ScfOp::Switch::Builder ScfOp::Builder::initSwitch() {
  _builder.setDataField<ScfOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, ScfOp::SWITCH);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).clear();
  return typename ScfOp::Switch::Builder(_builder);
}
inline bool ScfOp::Reader::isFor() const {
  return which() == ScfOp::FOR;
}
inline bool ScfOp::Builder::isFor() {
  return which() == ScfOp::FOR;
}
inline bool ScfOp::Reader::hasFor() const {
  if (which() != ScfOp::FOR) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ScfOp::Builder::hasFor() {
  if (which() != ScfOp::FOR) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::jeff::Region::Reader ScfOp::Reader::getFor() const {
  KJ_IREQUIRE((which() == ScfOp::FOR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::Region>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::jeff::Region::Builder ScfOp::Builder::getFor() {
  KJ_IREQUIRE((which() == ScfOp::FOR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::Region>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ScfOp::Builder::setFor( ::jeff::Region::Reader value) {
  _builder.setDataField<ScfOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, ScfOp::FOR);
  ::capnp::_::PointerHelpers< ::jeff::Region>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::jeff::Region::Builder ScfOp::Builder::initFor() {
  _builder.setDataField<ScfOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, ScfOp::FOR);
  return ::capnp::_::PointerHelpers< ::jeff::Region>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ScfOp::Builder::adoptFor(
    ::capnp::Orphan< ::jeff::Region>&& value) {
  _builder.setDataField<ScfOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, ScfOp::FOR);
  ::capnp::_::PointerHelpers< ::jeff::Region>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::jeff::Region> ScfOp::Builder::disownFor() {
  KJ_IREQUIRE((which() == ScfOp::FOR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::jeff::Region>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ScfOp::Reader::isWhile() const {
  return which() == ScfOp::WHILE;
}
inline bool ScfOp::Builder::isWhile() {
  return which() == ScfOp::WHILE;
}
inline typename ScfOp::While::Reader ScfOp::Reader::getWhile() const {
  KJ_IREQUIRE((which() == ScfOp::WHILE),
              "Must check which() before get()ing a union member.");
  return typename ScfOp::While::Reader(_reader);
}
inline typename ScfOp::While::Builder ScfOp::Builder::getWhile() {
  KJ_IREQUIRE((which() == ScfOp::WHILE),
              "Must check which() before get()ing a union member.");
  return typename ScfOp::While::Builder(_builder);
}
inline typename ScfOp::While::Builder ScfOp::Builder::initWhile() {
  _builder.setDataField<ScfOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, ScfOp::WHILE);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).clear();
  return typename ScfOp::While::Builder(_builder);
}
inline bool ScfOp::Reader::isDoWhile() const {
  return which() == ScfOp::DO_WHILE;
}
inline bool ScfOp::Builder::isDoWhile() {
  return which() == ScfOp::DO_WHILE;
}
inline typename ScfOp::DoWhile::Reader ScfOp::Reader::getDoWhile() const {
  KJ_IREQUIRE((which() == ScfOp::DO_WHILE),
              "Must check which() before get()ing a union member.");
  return typename ScfOp::DoWhile::Reader(_reader);
}
inline typename ScfOp::DoWhile::Builder ScfOp::Builder::getDoWhile() {
  KJ_IREQUIRE((which() == ScfOp::DO_WHILE),
              "Must check which() before get()ing a union member.");
  return typename ScfOp::DoWhile::Builder(_builder);
}
inline typename ScfOp::DoWhile::Builder ScfOp::Builder::initDoWhile() {
  _builder.setDataField<ScfOp::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, ScfOp::DO_WHILE);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  _builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).clear();
  return typename ScfOp::DoWhile::Builder(_builder);
}
inline bool ScfOp::Switch::Reader::hasBranches() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ScfOp::Switch::Builder::hasBranches() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::jeff::Region,  ::capnp::Kind::STRUCT>::Reader ScfOp::Switch::Reader::getBranches() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Region,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::jeff::Region,  ::capnp::Kind::STRUCT>::Builder ScfOp::Switch::Builder::getBranches() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Region,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ScfOp::Switch::Builder::setBranches( ::capnp::List< ::jeff::Region,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Region,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::jeff::Region,  ::capnp::Kind::STRUCT>::Builder ScfOp::Switch::Builder::initBranches(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Region,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void ScfOp::Switch::Builder::adoptBranches(
    ::capnp::Orphan< ::capnp::List< ::jeff::Region,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Region,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::jeff::Region,  ::capnp::Kind::STRUCT>> ScfOp::Switch::Builder::disownBranches() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::jeff::Region,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ScfOp::Switch::Reader::hasDefault() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ScfOp::Switch::Builder::hasDefault() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::jeff::Region::Reader ScfOp::Switch::Reader::getDefault() const {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::jeff::Region::Builder ScfOp::Switch::Builder::getDefault() {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::jeff::Region::Pipeline ScfOp::Switch::Pipeline::getDefault() {
  return  ::jeff::Region::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void ScfOp::Switch::Builder::setDefault( ::jeff::Region::Reader value) {
  ::capnp::_::PointerHelpers< ::jeff::Region>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::jeff::Region::Builder ScfOp::Switch::Builder::initDefault() {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ScfOp::Switch::Builder::adoptDefault(
    ::capnp::Orphan< ::jeff::Region>&& value) {
  ::capnp::_::PointerHelpers< ::jeff::Region>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::jeff::Region> ScfOp::Switch::Builder::disownDefault() {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool ScfOp::While::Reader::hasCondition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ScfOp::While::Builder::hasCondition() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::jeff::Region::Reader ScfOp::While::Reader::getCondition() const {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::jeff::Region::Builder ScfOp::While::Builder::getCondition() {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::jeff::Region::Pipeline ScfOp::While::Pipeline::getCondition() {
  return  ::jeff::Region::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void ScfOp::While::Builder::setCondition( ::jeff::Region::Reader value) {
  ::capnp::_::PointerHelpers< ::jeff::Region>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::jeff::Region::Builder ScfOp::While::Builder::initCondition() {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ScfOp::While::Builder::adoptCondition(
    ::capnp::Orphan< ::jeff::Region>&& value) {
  ::capnp::_::PointerHelpers< ::jeff::Region>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::jeff::Region> ScfOp::While::Builder::disownCondition() {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ScfOp::While::Reader::hasBody() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ScfOp::While::Builder::hasBody() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::jeff::Region::Reader ScfOp::While::Reader::getBody() const {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::jeff::Region::Builder ScfOp::While::Builder::getBody() {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::jeff::Region::Pipeline ScfOp::While::Pipeline::getBody() {
  return  ::jeff::Region::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void ScfOp::While::Builder::setBody( ::jeff::Region::Reader value) {
  ::capnp::_::PointerHelpers< ::jeff::Region>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::jeff::Region::Builder ScfOp::While::Builder::initBody() {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ScfOp::While::Builder::adoptBody(
    ::capnp::Orphan< ::jeff::Region>&& value) {
  ::capnp::_::PointerHelpers< ::jeff::Region>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::jeff::Region> ScfOp::While::Builder::disownBody() {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool ScfOp::DoWhile::Reader::hasBody() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ScfOp::DoWhile::Builder::hasBody() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::jeff::Region::Reader ScfOp::DoWhile::Reader::getBody() const {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::jeff::Region::Builder ScfOp::DoWhile::Builder::getBody() {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::jeff::Region::Pipeline ScfOp::DoWhile::Pipeline::getBody() {
  return  ::jeff::Region::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void ScfOp::DoWhile::Builder::setBody( ::jeff::Region::Reader value) {
  ::capnp::_::PointerHelpers< ::jeff::Region>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::jeff::Region::Builder ScfOp::DoWhile::Builder::initBody() {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ScfOp::DoWhile::Builder::adoptBody(
    ::capnp::Orphan< ::jeff::Region>&& value) {
  ::capnp::_::PointerHelpers< ::jeff::Region>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::jeff::Region> ScfOp::DoWhile::Builder::disownBody() {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ScfOp::DoWhile::Reader::hasCondition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ScfOp::DoWhile::Builder::hasCondition() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::jeff::Region::Reader ScfOp::DoWhile::Reader::getCondition() const {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::jeff::Region::Builder ScfOp::DoWhile::Builder::getCondition() {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::jeff::Region::Pipeline ScfOp::DoWhile::Pipeline::getCondition() {
  return  ::jeff::Region::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void ScfOp::DoWhile::Builder::setCondition( ::jeff::Region::Reader value) {
  ::capnp::_::PointerHelpers< ::jeff::Region>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::jeff::Region::Builder ScfOp::DoWhile::Builder::initCondition() {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ScfOp::DoWhile::Builder::adoptCondition(
    ::capnp::Orphan< ::jeff::Region>&& value) {
  ::capnp::_::PointerHelpers< ::jeff::Region>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::jeff::Region> ScfOp::DoWhile::Builder::disownCondition() {
  return ::capnp::_::PointerHelpers< ::jeff::Region>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint16_t FuncOp::Reader::getFuncCall() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t FuncOp::Builder::getFuncCall() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FuncOp::Builder::setFuncCall( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

}  // namespace

CAPNP_END_HEADER

