# Frequently asked questions

*Jeff* was designed to solve a few very specific problems the field is currently encountering:

- **We need to be able to compile large, complex, quantum algorithms, and this is an interdisclinary
    effort**. Compilation is an incredibly important component of quantum computing infrastructure.
    The inability to optimize large algorithms for future fault-tolerant hardware will extend
    (or block!) timelines for utility-scale quantum computation.

  However, there is still a lot of work to do, and a lot of uncertainty. We need to:

  - continue to make new theoretical compilation breakthroughs; 
  - identify the most-promising large scale algorithms; and finally,
  - figure out how to make this practical through quantum software.
  
  To do so, we need to bridge the gap between researchers doing fundamental compilation and
  algorithmic research, and quantum software developers.

  - **How can we share results and ideas faster, within a common framework?**
  - **How do we make sure we are speaking a common language, and aware of challenges and approaches
    on both sides?**

- **Quantum algorithms have structure that we need to preserve for scalability, but circuits are
  holding us back**. This is already recognized and built into common quantum software libraries
  (Qiskit, CUDA-Q, PennyLane, UCC, Guppy, TKET, etc.) and formats (QIR, OpenQASM3, etc.), but
  introduces complexity into the pipeline.

  * A majority 

## Is *Jeff* meant to be an intermediate format that quantum software packages to manipulate?

## Why design a non-human readable format?

## How did you decide what goes into the schema?

## Why do we need program structure?

## Why Cap'n Proto?

## Isn't this just *another* format standard?

## Why not format X?

### Why not OpenQASM2?

### Why not OpenQASM3?

### Why not QIR?

### Why not MLIR?
